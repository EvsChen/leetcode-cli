{"problems":[{"index":295,"title":"Find Median from Data Stream","body":{"mySolution":[{"time":"","space":"","code":"","language":""}],"optimizedSolution":[{"time":"$O(log(N))$ and $O(1)$","space":"$O(N)$","code":"from heapq import *\n\nclass MedianFinder:\n\n    def __init__(self):\n        \"\"\"\n        initialize your data structure here.\n        \"\"\"\n        # max heap\n        self.left = []\n        # min heap\n        self.right = []\n\n    def addNum(self, num: int) -> None:\n        # Balance the heap\n        heappush(self.right, -heappushpop(self.left, -num))\n        # Keep the size of left either equal or at worst greater than 1\n        if len(self.left) < len(self.right):\n            heappush(self.left, -heappop(self.right))\n\n    def findMedian(self) -> float:\n        if len(self.left) > len(self.right):\n            return -self.left[0]\n        return (-self.left[0] + self.right[0]) / 2","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/find-median-from-data-stream/","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [x] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem","Thinking":""},"desc":"Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.\r\nFor example,\r\n\r\n[2,3,4], the median is 3\r\n\r\n[2,3], the median is (2 + 3) / 2 = 2.5\r\n\r\nDesign a data structure that supports the following two operations:\r\n\r\n\r\n\tvoid addNum(int num) - Add a integer number from the data stream to the data structure.\r\n\tdouble findMedian() - Return the median of all elements so far.\r\n\r\n\r\n \r\n\r\nExample:\r\n\r\n\r\naddNum(1)\r\naddNum(2)\r\nfindMedian() -> 1.5\r\naddNum(3) \r\nfindMedian() -> 2\r\n\r\n\r\n \r\n\r\nFollow up:\r\n\r\n\r\n\tIf all integer numbers from the stream are between 0 and 100, how would you optimize it?\r\n\tIf 99% of all integer numbers from the stream are between 0 and 100, how would you optimize it?\r\n\r\n"},{"index":146,"title":"LRU Cache","body":{"mySolution":[],"optimizedSolution":[{"time":"$O(1)$","space":"$O(N)$","code":"class DLNode:\n    def __init__(self, key = 0, value = 0):\n        self.key = key\n        self.value = value\n        self.prev = None\n        self.next = None\n\nclass LRUCache:\n    def _add_node(self, node: DLNode):\n        node.prev = self.head\n        node.next = self.head.next\n        self.head.next.prev = node\n        self.head.next = node\n    \n    def _remove_node(self, node: DLNode):\n        node.prev.next = node.next\n        node.next.prev = node.prev\n        \n    def _move_to_head(self, node: DLNode):\n        self._remove_node(node)\n        self._add_node(node)\n        \n    def _pop_tail(self):\n        node = self.tail.prev\n        self._remove_node(node)\n        return node\n        \n    def __init__(self, capacity: int):\n        self.capacity = capacity\n        self.cache = dict()\n        self.head = DLNode()\n        self.tail = DLNode()\n        self.head.next = self.tail\n        self.tail.prev = self.head\n        \n    def get(self, key: int) -> int:\n        if key not in self.cache:\n            return -1\n        node = self.cache[key]\n        self._move_to_head(node)\n        return node.value\n\n    def put(self, key: int, value: int) -> None:\n        if key in self.cache:\n            node = self.cache[key]\n            node.value = value\n            self._move_to_head(node)\n            return\n        \n        node = DLNode(key, value)\n        if len(self.cache) == self.capacity:\n            tail = self._pop_tail()\n            del self.cache[tail.key]\n            \n        self.cache[key] = node\n        self._add_node(node)\n        \n        \n# Your LRUCache object will be instantiated and called as such:\n# obj = LRUCache(capacity)\n# param_1 = obj.get(key)\n# obj.put(key,value)","language":"python"},{"time":"$O(1)$","space":"$O(N)$","code":"class LRUCache {\npublic:\n    int size;\n    list<int> lru; // MRU...LRU\n    unordered_map<int, int> val_map;\n    unordered_map<int, list<int>::iterator> itr_map;\n    \n    LRUCache(int capacity) : size(capacity) {}\n    \n    int get(int key) {\n        if (val_map.find(key) == val_map.end()) {\n            return -1;\n        }\n        updateKey(key);\n        return val_map[key];\n    }\n    \n    void put(int key, int value) {\n        if (val_map.size() == size && val_map.find(key) == val_map.end()) {\n            invalidate();\n        }\n        updateKey(key);\n        val_map[key] = value;\n    }\n    \n    void invalidate() {\n        val_map.erase(lru.back());\n        itr_map.erase(lru.back());\n        lru.pop_back();\n    }\n    \n    void updateKey(int key) {\n        if (itr_map.find(key) != itr_map.end()) {\n            lru.erase(itr_map[key]);            \n        }\n        lru.push_front(key);\n        itr_map[key] = lru.begin();\n    }\n};","language":"cpp"}],"anki":"","Link":"https://leetcode.com/problems/lru-cache/","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [ ] can-optimize\n- [x] not-intuitive\n- [ ] bad-problem","Test cases":"* [\"LRUCache\",\"get\",\"put\",\"get\",\"put\",\"put\",\"get\",\"get\"]\n  [[2],[2],[2,6],[1],[1,5],[1,2],[1],[2]]"},"desc":"Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and put.\r\n\r\nget(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.\r\nput(key, value) - Set or insert the value if the key is not already present. When the cache reached its capacity, it should invalidate the least recently used item before inserting a new item.\r\n\r\nThe cache is initialized with a positive capacity.\r\n\r\nFollow up:\r\nCould you do both operations in O(1) time complexity?\r\n\r\nExample:\r\n\r\n\r\nLRUCache cache = new LRUCache( 2 /* capacity */ );\r\n\r\ncache.put(1, 1);\r\ncache.put(2, 2);\r\ncache.get(1);       // returns 1\r\ncache.put(3, 3);    // evicts key 2\r\ncache.get(2);       // returns -1 (not found)\r\ncache.put(4, 4);    // evicts key 1\r\ncache.get(1);       // returns -1 (not found)\r\ncache.get(3);       // returns 3\r\ncache.get(4);       // returns 4\r\n\r\n\r\n \r\n"},{"index":40,"title":"Combination Sum II","body":{"mySolution":[],"optimizedSolution":[],"anki":""},"desc":"Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.\r\n\r\nEach number in candidates may only be used once in the combination.\r\n\r\nNote:\r\n\r\n\r\n\tAll numbers (including target) will be positive integers.\r\n\tThe solution set must not contain duplicate combinations.\r\n\r\n\r\nExample 1:\r\n\r\n\r\nInput: candidates = [10,1,2,7,6,1,5], target = 8,\r\nA solution set is:\r\n[\r\n  [1, 7],\r\n  [1, 2, 5],\r\n  [2, 6],\r\n  [1, 1, 6]\r\n]\r\n\r\n\r\nExample 2:\r\n\r\n\r\nInput: candidates = [2,5,2,1,2], target = 5,\r\nA solution set is:\r\n[\r\n  [1,2,2],\r\n  [5]\r\n]\r\n\r\n"},{"index":253,"title":"Meeting Rooms II","body":{"mySolution":[{"time":"$O(Nlog(N))$","space":"$O(N)$","code":"class Solution:\n    def minMeetingRooms(self, intervals: List[List[int]]) -> int:\n        start = [i[0] for i in intervals]\n        end = [i[1] for i in intervals]\n        start.sort()\n        end.sort()\n        num = max_num = 0\n        p1 = p2 = 0\n        # We sort the start and end time respectively in increasing order\n        # Then we traverse through both lists\n        # We add the number of meeting rooms by 1 for each start\n        # Decrease by 1 for each end\n        while p1 < len(intervals) and p2 < len(intervals):\n            if start[p1] < end[p2]:\n                num += 1\n                p1 += 1\n            elif end[p2] > start[p1]:\n                num -=  1\n                p2 += 1\n            else:\n                p1 += 1\n                p2 += 1\n            \n            max_num = max(max_num, num)\n        \n        return max_num","language":""}],"optimizedSolution":[{"time":"$O(Nlog(N)$","space":"$O(N)$","code":"class Solution:\n    def minMeetingRooms(self, intervals: List[List[int]]) -> int:\n        start = [i[0] for i in intervals]\n        end = [i[1] for i in intervals]\n        start.sort()\n        end.sort()\n        num = 0\n        p1 = p2 = 0\n        # Instead of going through the entire list, we only need to go through the start time list.\n        while p1 < len(intervals):\n            if start[p1] >= end[p2]:\n                num -=  1\n                p2 += 1\n            num += 1\n            p1 += 1\n        \n        # Since the number of meeting rooms after all start time have been traversed must be the largest\n        # we don't need a max_num\n        return num","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/meeting-rooms-ii/","Solved":"- [x] solved\n- [ ] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [x] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem","Thinking":""},"desc":"Given an array of meeting time intervals consisting of start and end times [[s1,e1],[s2,e2],...] (si < ei), find the minimum number of conference rooms required.\r\n\r\nExample 1:\r\n\r\n\r\nInput: [[0, 30],[5, 10],[15, 20]]\r\nOutput: 2\r\n\r\nExample 2:\r\n\r\n\r\nInput: [[7,10],[2,4]]\r\nOutput: 1\r\n\r\nNOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.\r\n"},{"index":119,"title":"Pascal's Triangle II","body":{"mySolution":[{"time":"$O(N)$","space":"$O(N)$","code":"class Solution:\n    # Use formula\n    def getRow(self, rowIndex: int) -> List[int]:\n        res = [1] * (rowIndex + 1)\n        i = 1\n        while i <= len(res) - 1 - i:\n            res[i] = res[len(res) - 1 - i] = res[i - 1] * (rowIndex - i + 1) // i\n            i += 1\n        return res","language":"python"}],"optimizedSolution":[{"time":"$O(N^2)$","space":"$O(N)$","code":"class Solution:\n    # Calculate Pascal's triangle without using extra space\n    def getRow(self, rowIndex: int) -> List[int]:\n        res = [0] * (rowIndex + 1)\n        res[0] = 1\n        for i in range(1, rowIndex + 1):\n            for j in range(i, 0, -1):\n                res[j] += res[j - 1]\n        return res","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/pascals-triangle-ii/","Solved":"- [x] solved\n- [ ] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [x] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem","Thinking":""},"desc":"Given a non-negative index k where k ≤ 33, return the k^th index row of the Pascal's triangle.\r\n\r\nNote that the row index starts from 0.\r\n\r\n\r\nIn Pascal's triangle, each number is the sum of the two numbers directly above it.\r\n\r\nExample:\r\n\r\n\r\nInput: 3\r\nOutput: [1,3,3,1]\r\n\r\n\r\nFollow up:\r\n\r\nCould you optimize your algorithm to use only O(k) extra space?\r\n"},{"index":10,"title":"Regular Expression Matching","body":{"mySolution":[],"optimizedSolution":[{"time":"$O(S * P)$","space":"$O(S * P)$","code":"class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        # We use extra space here for boundary handling\n        # dp[i][j] represents whether p[:i] can match s[:j]\n        dp = [[False] * (len(s) + 1) for _ in range(len(p) + 1)]\n        dp[0][0] = True\n        # Init the first column\n        for i in range(2, len(p) + 1):\n            dp[i][0] = p[i - 1] == '*' and dp[i - 2][0]\n        \n        for i in range(1, len(p) + 1):\n            for j in range(1, len(s) + 1):\n                if p[i - 1] != '*':\n                    # For regular letters or '.', we look at the diagonal element\n                    dp[i][j] = dp[i - 1][j - 1] and (p[i - 1] == s[j - 1] or p[i - 1] == '.')\n                else:\n                    # If p[i - 1] == '*', either\n                    # 1. '*' does not match anything, we just skip '*' and the letter before\n                    # 2. The letter before is the same as s[j - 1], it can match 0 or more times\n                    first_match = p[i - 2] == s[j - 1] or p[i - 2] == '.'\n                    dp[i][j] = (i > 1 and dp[i - 2][j]) or (first_match and dp[i][j - 1])\n        \n        return dp[len(p)][len(s)]","language":"python"}],"anki":"Use 2d dynamic programming, where `dp[i][j]` represents whether `s[:i]` and `p[:j]` match each other. Matrix size is one more than the length of str and pattern to handle boudary conditions.","Link":"https://leetcode.com/problems/regular-expression-matching/","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [ ] can-optimize\n- [x] not-intuitive\n- [ ] bad-problem"},"desc":"Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'.\n\n\n'.' Matches any single character.\n'*' Matches zero or more of the preceding element.\n\n\nThe matching should cover the entire input string (not partial).\n\nNote:\n\n\n\ts could be empty and contains only lowercase letters a-z.\n\tp could be empty and contains only lowercase letters a-z, and characters like . or *.\n\n\nExample 1:\n\n\nInput:\ns = \"aa\"\np = \"a\"\nOutput: false\nExplanation: \"a\" does not match the entire string \"aa\".\n\n\nExample 2:\n\n\nInput:\ns = \"aa\"\np = \"a*\"\nOutput: true\nExplanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\".\n\n\nExample 3:\n\n\nInput:\ns = \"ab\"\np = \".*\"\nOutput: true\nExplanation: \".*\" means \"zero or more (*) of any character (.)\".\n\n\nExample 4:\n\n\nInput:\ns = \"aab\"\np = \"c*a*b\"\nOutput: true\nExplanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches \"aab\".\n\n\nExample 5:\n\n\nInput:\ns = \"mississippi\"\np = \"mis*is*p*.\"\nOutput: false\n\n"},{"index":102,"title":"Binary Tree Level Order Traversal","body":{"mySolution":[{"time":"$O(N)$ where $N$ is the number of nodes","space":"$O(N)$","code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def levelOrder(self, root: TreeNode) -> List[List[int]]:\n        self.q = []\n        self.rec(0, root)\n        return self.q\n    \n    def rec(self, level, node):\n        if not node: return\n        \n        if len(self.q) < level + 1:\n            self.q.append([])\n        \n        self.q[level].append(node.val)\n        self.rec(level + 1, node.left)\n        self.rec(level + 1, node.right)\n","language":"python"},{"time":"$O(N)$","space":"$O(N)$","code":"from collections import deque\nclass Solution:\n    def levelOrder(self, root: TreeNode) -> List[List[int]]:\n        res = []\n        q = deque([root, ])\n        while q:\n            level_res = []\n            pre_len = len(q)\n            for i in range(pre_len):\n                n = q.popleft()\n                if n:\n                    level_res.append(n.val)\n                    q.append(n.left)\n                    q.append(n.right)\n            \n            if len(level_res) > 0: res.append(level_res)\n        \n        return res","language":"python"}],"optimizedSolution":[],"anki":"","Link":"https://leetcode.com/problems/binary-tree-level-order-traversal/","Solved":"- [x] solved\n- [ ] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [x] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem"},"desc":"Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).\r\n\r\n\r\nFor example:\r\nGiven binary tree [3,9,20,null,null,15,7],\r\n\r\n    3\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7\r\n\r\n\r\n\r\nreturn its level order traversal as:\r\n\r\n[\r\n  [3],\r\n  [9,20],\r\n  [15,7]\r\n]\r\n\r\n"},{"index":287,"title":"Find the Duplicate Number","body":{"mySolution":[{"time":"","space":"","code":"","language":""}],"optimizedSolution":[{"time":"$O(N)$","space":"$O(1)$","code":"class Solution:\n    def findDuplicate(self, nums: List[int]) -> int:\n        def nx(n):\n            return nums[n]\n        \n        slow = fast = nums[0]\n        \n        while True:\n            slow = nx(slow)\n            fast = nx(nx(fast))\n            if slow == fast:\n                break\n            \n        node = nx(0)\n        \n        while node != fast:\n            fast = nx(fast)\n            node = nx(node)\n            \n        return fast","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/find-the-duplicate-number/","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [ ] can-optimize\n- [x] not-intuitive\n- [ ] bad-problem","Thinking":""},"desc":"Given an array nums containing n + 1 integers where each integer is between 1 and n (inclusive), prove that at least one duplicate number must exist. Assume that there is only one duplicate number, find the duplicate one.\r\n\r\nExample 1:\r\n\r\n\r\nInput: [1,3,4,2,2]\r\nOutput: 2\r\n\r\n\r\nExample 2:\r\n\r\n\r\nInput: [3,1,3,4,2]\r\nOutput: 3\r\n\r\nNote:\r\n\r\n\r\n\tYou must not modify the array (assume the array is read only).\r\n\tYou must use only constant, O(1) extra space.\r\n\tYour runtime complexity should be less than O(n^2).\r\n\tThere is only one duplicate number in the array, but it could be repeated more than once.\r\n\r\n"},{"index":234,"title":"Palindrome Linked List","body":{"mySolution":[{"time":"$O(N)$","space":"$O(N^2)$","code":"Post my solution here, if solved successfully.","language":""}],"optimizedSolution":[{"time":"$O(N)$","space":"$O(1)$","code":"class Solution:\n    def isPalindrome(self, head):\n        rev = None\n        slow = fast = head\n        while fast and fast.next:\n            fast = fast.next.next\n            rev, rev.next, slow = slow, rev, slow.next\n        if fast:\n            slow = slow.next\n        while rev and rev.val == slow.val:\n            slow = slow.next\n            rev = rev.next\n        return not rev","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/palindrome-linked-list/","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [ ] can-optimize\n- [x] not-intuitive\n- [ ] bad-problem","Thinking":""},"desc":"Given a singly linked list, determine if it is a palindrome.\r\n\r\nExample 1:\r\n\r\n\r\nInput: 1->2\r\nOutput: false\r\n\r\nExample 2:\r\n\r\n\r\nInput: 1->2->2->1\r\nOutput: true\r\n\r\nFollow up:\r\nCould you do it in O(n) time and O(1) space?\r\n"},{"index":212,"title":"Word Search II","body":{"mySolution":[{"time":"$O(N)$","space":"$O(N^2)$","code":"# Got TLE for this\nclass Solution(object):\n    def findWords(self, board, words):\n        \"\"\"\n        :type board: List[List[str]]\n        :type words: List[str]\n        :rtype: List[str]\n        \"\"\"\n        if len(words) == 0:\n            return []\n        if not board or not board[0]:\n            return []\n\n        word_set = set(words)\n        res = set()\n        len_list = [len(w) for w in words]\n        self.max_len = max(len_list)\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                self.helper(i * len(board[0]) + j, board, set(), [], word_set, res)\n        return list(res)\n    \n    \n    def helper(self, coord, board, history, arr, word_set, res):\n        if coord in history:\n            return\n        history.add(coord)\n        y = coord % len(board[0])\n        x = coord // len(board[0])\n        arr.append(board[x][y])\n        current = ''.join(arr)\n        if current in word_set:\n            res.add(current)\n        \n        isPrefix = False\n        for word in word_set:\n            if word.startswith(current):\n                isPrefix = True\n                break\n            \n        if len(arr) < self.max_len and isPrefix:\n            if x != len(board) - 1:\n                self.helper((x + 1) * len(board[0]) + y, board, history, arr, word_set, res)\n            if x != 0:\n                self.helper((x - 1) * len(board[0]) + y, board, history, arr, word_set, res)\n            if y != len(board[0]) - 1:\n                self.helper(x * len(board[0]) + y + 1, board, history, arr, word_set, res)\n            if y != 0:\n                self.helper(x * len(board[0]) + y - 1, board, history, arr, word_set, res)\n        arr.pop()\n        history.remove(coord)","language":"python"}],"optimizedSolution":[{"time":"$O(M*N*4^wl)$ where wl is the average length of words in wordlist","space":"$O(V)$ number of vertices in Trie","code":"class TrieNode:\n    def __init__(self):\n        self.next = {}\n        self.word = None\n    \ndef buildTrie(words):\n    root = TrieNode()\n    for w in words:\n        node = root\n        for i in range(len(w)):\n            c = w[i]\n            if c not in node.next:\n                node.next[c] = TrieNode()\n            node = node.next[c]\n            if i == len(w) - 1:\n                node.word = w\n    return root\n    \nclass Solution:\n    def findWords(self, board: List[List[str]], words: List[str]) -> List[str]:\n        if not words or not board or not board[0]:\n            return []\n        root = buildTrie(words)\n        res = []\n        for i in range(len(board)):\n            for j in range(len(board[0])):\n                self.dfs(i * len(board[0]) + j, board, root, res)\n        return res\n    \n    def dfs(self, coord, board, node, res):\n        x = coord // len(board[0])\n        y = coord % len(board[0])\n        \n        if board[x][y] == '#' or board[x][y] not in node.next:\n            return\n        \n        node = node.next[board[x][y]]\n        if node.word:\n            res.append(node.word)\n            node.word = None\n        \n        temp, board[x][y] = board[x][y], '#'\n        if x != 0:\n            self.dfs((x - 1) * len(board[0]) + y, board, node, res)\n        if x != len(board) - 1:\n            self.dfs((x + 1) * len(board[0]) + y, board, node, res)\n        if y != len(board[0]) - 1:\n            self.dfs(x * len(board[0]) + y + 1, board, node, res)\n        if y != 0:\n            self.dfs(x * len(board[0]) + y - 1, board, node, res)\n        board[x][y] = temp\n    \n","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/word-search-ii/","Related":"","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [ ] can-optimize\n- [x] not-intuitive\n- [ ] bad-problem","Test Cases":""},"desc":"Given a 2D board and a list of words from the dictionary, find all words in the board.\r\n\r\nEach word must be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once in a word.\r\n\r\n \r\n\r\nExample:\r\n\r\n\r\nInput: \r\nboard = [\r\n  ['o','a','a','n'],\r\n  ['e','t','a','e'],\r\n  ['i','h','k','r'],\r\n  ['i','f','l','v']\r\n]\r\nwords = [\"oath\",\"pea\",\"eat\",\"rain\"]\r\n\r\nOutput: [\"eat\",\"oath\"]\r\n\r\n\r\n \r\n\r\nNote:\r\n\r\n\r\n\tAll inputs are consist of lowercase letters a-z.\r\n\tThe values of words are distinct.\r\n\r\n"},{"index":494,"title":"Target Sum","body":{"mySolution":[{"time":"$O(N)$","space":"$O(N^2)$","code":"class Solution:\n    def findTargetSumWays(self, nums: List[int], S: int) -> int:\n        if not nums:\n            return 0\n        \n        # Use a cache to optimize speed\n        cache = [{} for _ in nums]\n        max_sum = [0] * len(nums)\n        max_sum[-1] = nums[-1]\n        for i in range(len(nums) - 2, -1, -1):\n            max_sum[i] = max_sum[i + 1] + nums[i]\n        \n        # Use recursion\n        # Each time we change the target to be target + nums[i] and target - nums[i]\n        # and move the pointer forward\n        def rec(start, target):\n            # Base case\n            if start == len(nums) - 1:\n                # Be careful when the number is 0\n                if nums[start] == 0:\n                    return 2 if target == 0 else 0\n                return int(target == nums[start] or target == -nums[start])\n            \n            if target in cache[start]:\n                return cache[start][target]\n            \n            # Early return by comparing the target with the max_sum that can offer\n            if target > max_sum[start] or target < -max_sum[start]:\n                return 0\n            \n            res = rec(start + 1, target + nums[start]) + rec(start + 1, target - nums[start])\n            cache[start][target] = res\n            return res\n        \n        return rec(0, S)","language":"python"}],"optimizedSolution":[{"time":"$O(N)$","space":"$O(N^2)$","code":"class Solution:\n    def findTargetSumWays(self, nums: List[int], S: int) -> int:\n        if not nums:\n            return 0\n        \n        cache = [{} for _ in nums]\n        max_sum = [0] * len(nums)\n        max_sum[-1] = nums[-1]\n        for i in range(len(nums) - 2, -1, -1):\n            max_sum[i] = max_sum[i + 1] + nums[i]\n        \n        def rec(start, target):\n            # Since the result for positive and negative numbers are the same,\n            # we can optimize the speed by considering only positive ones\n            if target < 0:\n                target = -target\n\n            if start == len(nums) - 1:\n                if nums[start] == 0:\n                    return 2 if target == 0 else 0\n                return int(target == nums[start])\n            \n            if target in cache[start]:\n                return cache[start][target]\n            \n            if target > max_sum[start]:\n                return 0\n            \n            res = rec(start + 1, target + nums[start]) + rec(start + 1, target - nums[start])\n            cache[start][target] = res\n            return res\n        \n        return rec(0, S)","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/target-sum/","Solved":"- [x] solved\n- [ ] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [x] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem","Thinking":""},"desc":"\r\nYou are given a list of non-negative integers, a1, a2, ..., an, and a target, S. Now you have 2 symbols + and -. For each integer, you should choose one from + and - as its new symbol.\r\n \r\n\r\nFind out how many ways to assign symbols to make sum of integers equal to target S.  \r\n\r\n\r\nExample 1:\r\n\r\nInput: nums is [1, 1, 1, 1, 1], S is 3. \r\nOutput: 5\r\nExplanation: \r\n\r\n-1+1+1+1+1 = 3\r\n+1-1+1+1+1 = 3\r\n+1+1-1+1+1 = 3\r\n+1+1+1-1+1 = 3\r\n+1+1+1+1-1 = 3\r\n\r\nThere are 5 ways to assign symbols to make the sum of nums be target 3.\r\n\r\n\r\n\r\nNote:\r\n\r\nThe length of the given array is positive and will not exceed 20. \r\nThe sum of elements in the given array will not exceed 1000.\r\nYour output answer is guaranteed to be fitted in a 32-bit integer.\r\n\r\n"},{"index":973,"title":"K Closest Points to Origin","body":{"mySolution":[],"optimizedSolution":[{"time":"$O(NlogK)$","space":"$O(K)$","code":"// TODO: using priority queue","language":"cpp"},{"time":"average $O(N)$, worst case $O(N^2)$ TODO: why average O(N)?","space":"$O(1)$","code":"// Also called quick select\nclass Solution {\npublic:\n    vector<vector<int>> kClosest(vector<vector<int>>& points, int K) {\n        sort(points, 0, points.size() - 1, K);\n        points.resize(K);\n        return points;\n    }\n    \n    // Partially sort the first K points by randomly selecting a pivot\n    void sort(vector<vector<int>> &points, int i, int j, int K) {\n        if (i >= j) {\n            return;\n        }\n        int pivot = rand() % (j - i) + i;\n        swap(points[pivot], points[i]);\n        int mid = partition(points, i, j);\n\n        if (mid - i + 1 < K) {\n            sort(points, mid + 1, j, K - mid + i - 1);\n        }\n        else if (mid - i + 1 > K) {\n            sort(points, i, mid - 1, K);\n        }\n    }\n    \n    int dist(vector<int> &point) {\n        return point[0] * point[0] + point[1] * point[1];\n    }\n    \n    // Need careful manipulation here\n    int partition(vector<vector<int>> &points, int i, int j) {\n        int pivot = dist(points[i]);\n        int start = i;\n        i++;\n        while (true) {\n            while (i <= j && dist(points[i]) <= pivot) i++;\n            while (i <= j && dist(points[j]) > pivot) j--;\n            if (i > j) break;\n            swap(points[i], points[j]);\n        }\n        swap(points[start], points[j]);\n        return j;\n    }\n};","language":"cpp"}],"anki":"","Link":"https://leetcode.com/problems/k-closest-points-to-origin/","Related":"","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [ ] can-optimize\n- [x] not-intuitive\n- [ ] bad-problem","Test Cases":"[[-1,3],[-2,2],[2,-2]] K=2"},"desc":"We have a list of points on the plane.  Find the K closest points to the origin (0, 0).\r\n\r\n(Here, the distance between two points on a plane is the Euclidean distance.)\r\n\r\nYou may return the answer in any order.  The answer is guaranteed to be unique (except for the order that it is in.)\r\n\r\n \r\n\r\n\r\nExample 1:\r\n\r\n\r\nInput: points = [[1,3],[-2,2]], K = 1\r\nOutput: [[-2,2]]\r\nExplanation: \r\nThe distance between (1, 3) and the origin is sqrt(10).\r\nThe distance between (-2, 2) and the origin is sqrt(8).\r\nSince sqrt(8) < sqrt(10), (-2, 2) is closer to the origin.\r\nWe only want the closest K = 1 points from the origin, so the answer is just [[-2,2]].\r\n\r\n\r\n\r\nExample 2:\r\n\r\n\r\nInput: points = [[3,3],[5,-1],[-2,4]], K = 2\r\nOutput: [[3,3],[-2,4]]\r\n(The answer [[-2,4],[3,3]] would also be accepted.)\r\n\r\n\r\n \r\n\r\nNote:\r\n\r\n\r\n\t1 <= K <= points.length <= 10000\r\n\t-10000 < points[i][0] < 10000\r\n\t-10000 < points[i][1] < 10000\r\n\r\n\r\n"},{"index":127,"title":"Word Ladder","body":{"mySolution":[{"time":"","space":"","code":"","language":""}],"optimizedSolution":[{"time":"$O(N * L)$ where $N$ is the lenth of the list and $L$ is the size of word","space":"$O(N * L)$","code":"from collections import defaultdict, deque\n\nclass Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        if endWord not in wordList:\n            return 0\n        \n        if beginWord not in wordList:\n            wordList += [beginWord]\n        \n        # Use the middle state as key, for example, '*og', 'h*g', 'ho*' for 'hog'\n        graph = defaultdict(list)\n        # Save all the middle states for one word to avoid recalculating\n        states = {}\n        \n        for i in range(len(wordList)):\n            word = wordList[i]\n            states[word] = [word[:j] + '*' + word[j + 1:] for j in range(len(word))]\n            for key in states[word]:\n                graph[key].append(word)\n        \n        # Use a set to avoid revisit\n        history = set()\n        q = deque([(beginWord, 1)])\n        \n        while q:\n            w, s = q.popleft()\n            if w == endWord:\n                return s\n            history.add(w)\n            for state in states[w]:\n                for n in graph[state]:\n                    if n not in history:\n                        q.append((n, s + 1))\n                # This step is important to avoid revisit\n                graph[state] = []\n        \n        return 0","language":"python"},{"time":"$O(N * L)$ where $N$ is the lenth of the list and $L$ is the size of word","space":"$O(N * L)$","code":"from collections import defaultdict, deque\n\nclass Solution:\n    # Bidirectional search\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        if endWord not in set(wordList):\n            return 0\n        \n        self.graph = defaultdict(list)\n        self.states = {}\n        \n        for i in range(len(wordList)):\n            word = wordList[i]\n            self.states[word] = [word[:j] + '*' + word[j + 1:] for j in range(len(word))]\n            for key in self.states[word]:\n                self.graph[key].append(word)\n                \n        self.states[beginWord] = [beginWord[:j] + '*' + beginWord[j + 1:] for j in range(len(beginWord))]\n        \n        # We search from both ends\n        beginq = deque([(beginWord, 1)])\n        endq = deque([(endWord, 1)])\n        beginhis = { beginWord: 1 }\n        endhis = { endWord: 1 }\n        \n        while beginq or endq:\n            # Return if both ends met\n            ans = self.search(beginq, beginhis, endhis)\n            if ans:\n                return ans\n            ans = self.search(endq, endhis, beginhis)\n            if ans:\n                return ans\n            \n        return 0\n    \n    def search(self, wordq, his, otherhis):\n        if not wordq:\n            return None\n        w,s = wordq.popleft()\n        for state in self.states[w]:\n            for n in self.graph[state]:\n                if n in otherhis:\n                    return s + otherhis[n]\n                if n not in his:\n                    his[n] = s + 1\n                    wordq.append((n, s + 1))\n            self.graph[state] = []\n        \n        return None","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/word-ladder/","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [x] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem","Thinking":""},"desc":"Given two words (beginWord and endWord), and a dictionary's word list, find the length of shortest transformation sequence from beginWord to endWord, such that:\r\n\r\n\r\n\tOnly one letter can be changed at a time.\r\n\tEach transformed word must exist in the word list. Note that beginWord is not a transformed word.\r\n\r\n\r\nNote:\r\n\r\n\r\n\tReturn 0 if there is no such transformation sequence.\r\n\tAll words have the same length.\r\n\tAll words contain only lowercase alphabetic characters.\r\n\tYou may assume no duplicates in the word list.\r\n\tYou may assume beginWord and endWord are non-empty and are not the same.\r\n\r\n\r\nExample 1:\r\n\r\n\r\nInput:\r\nbeginWord = \"hit\",\r\nendWord = \"cog\",\r\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\r\n\r\nOutput: 5\r\n\r\nExplanation: As one shortest transformation is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\",\r\nreturn its length 5.\r\n\r\n\r\nExample 2:\r\n\r\n\r\nInput:\r\nbeginWord = \"hit\"\r\nendWord = \"cog\"\r\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\r\n\r\nOutput: 0\r\n\r\nExplanation: The endWord \"cog\" is not in wordList, therefore no possible transformation.\r\n\r\n\r\n\r\n\r\n"},{"index":75,"title":"Sort Colors","body":{"mySolution":[],"optimizedSolution":[{"time":"$O(N)$","space":"$O(1)$","code":"class Solution:\n    def sortColors(self, nums: List[int]) -> None:\n        \"\"\"\n        Do not return anything, modify nums in-place instead.\n        \"\"\"\n        i = p0 = 0\n        p2 = len(nums) - 1\n        while i <= p2:\n            if nums[i] == 0:\n                nums[i], nums[p0] = nums[p0], nums[i]\n                p0 += 1\n                i += 1\n            elif nums[i] == 2:\n                nums[i], nums[p2] = nums[p2], nums[i]\n                p2 -=1\n            else:\n                i += 1","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/sort-colors/","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [ ] can-optimize\n- [x] not-intuitive\n- [ ] bad-problem","Thinking":"I was thinking to store the last position of 0, 1 and 2 in three pointers. And rearrange them each time. But it seems that it would take more time than the two pass"},"desc":"Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.\r\n\r\nHere, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.\r\n\r\nNote: You are not suppose to use the library's sort function for this problem.\r\n\r\nExample:\r\n\r\n\r\nInput: [2,0,2,1,1,0]\r\nOutput: [0,0,1,1,2,2]\r\n\r\nFollow up:\r\n\r\n\r\n\tA rather straight forward solution is a two-pass algorithm using counting sort.\r\n\tFirst, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's.\r\n\tCould you come up with a one-pass algorithm using only constant space?\r\n\r\n"},{"index":581,"title":"Shortest Unsorted Continuous Subarray","body":{"mySolution":[{"time":"","space":"","code":"","language":""}],"optimizedSolution":[{"time":"$O(N)$","space":"$O(N)$","code":"class Solution:\n    def findUnsortedSubarray(self, nums: List[int]) -> int:\n        stack = []\n        start = len(nums)\n        end = -1\n        for i in range(len(nums)):\n            while stack and nums[stack[-1]] > nums[i]:\n                start = min(start, stack.pop())\n            stack.append(i)\n        stack.clear()\n        for i in range(len(nums) - 1, -1, -1):\n            while stack and nums[stack[-1]] < nums[i]:\n                end = max(end, stack.pop())\n            stack.append(i)\n        \n        return 0 if end == -1 else end - start + 1","language":"python"},{"time":"$O(N)$","space":"$O(1)$","code":"class Solution:\n    def findUnsortedSubarray(self, nums: List[int]) -> int:\n        cur_max = float('-inf')\n        cur_min = float('inf')\n        flag = False\n        for i in range(1, len(nums)):\n            # As long as the array begins falling,\n            # we look for the minimum element in the falling array \n            if nums[i] < nums[i - 1]:\n                flag = True\n            if flag:\n                cur_min = min(cur_min, nums[i])\n        flag = False\n        for i in range(len(nums) - 2, -1, -1):\n            # Similarly, when looking backwards\n            # We look for the maximum element in the rising array\n            if nums[i] > nums[i + 1]:\n                flag = True\n            if flag:\n                cur_max = max(cur_max, nums[i])\n        end = start = -1\n        # Then we look for the right positions for cur_min and cur_max\n        for start in range(len(nums)):\n            if nums[start] > cur_min:\n                break\n        for end in range(len(nums) - 1, -1, -1):\n            if nums[end] < cur_max:\n                break\n        return 0 if end <= start else end - start + 1","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/shortest-unsorted-continuous-subarray/","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [ ] can-optimize\n- [x] not-intuitive\n- [ ] bad-problem","Thinking":""},"desc":"Given an integer array, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too.  \r\n\r\nYou need to find the shortest such subarray and output its length.\r\n\r\nExample 1:\r\n\r\nInput: [2, 6, 4, 8, 10, 9, 15]\r\nOutput: 5\r\nExplanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.\r\n\r\n\r\n\r\nNote:\r\n\r\nThen length of the input array is in range [1, 10,000].\r\nThe input array may contain duplicates, so ascending order here means . \r\n\r\n"},{"index":312,"title":"Burst Balloons","body":{"mySolution":[{"time":"","space":"","code":"","language":""}],"optimizedSolution":[{"time":"$O(N^3)$ still not sure about this. Posted a comment under [the official solution](https://leetcode.com/articles/burst-balloons/)","space":"$O(N^2)$","code":"from functools import lru_cache\n\nclass Solution:\n    def maxCoins(self, nums: List[int]) -> int:\n\n        # reframe the problem\n        nums = [1] + nums + [1]\n\n        # cache this\n        @lru_cache(None)\n        def dp(left, right):\n            # no more balloons can be added\n            if left + 1 == right: return 0\n\n            # add each balloon on the interval and return the maximum score\n            return max(nums[left] * nums[i] * nums[right] + dp(left, i) + dp(i, right) for i in range(left+1, right))\n\n        # find the maximum number of coins obtained from adding all balloons from (0, len(nums) - 1)\n        return dp(0, len(nums)-1)","language":""}],"anki":"","Link":"https://leetcode.com/problems/burst-balloons/","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [ ] can-optimize\n- [x] not-intuitive\n- [ ] bad-problem","Thinking":""},"desc":"Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] * nums[i] * nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent.\r\n\r\nFind the maximum coins you can collect by bursting the balloons wisely.\r\n\r\nNote:\r\n\r\n\r\n\tYou may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them.\r\n\t0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100\r\n\r\n\r\nExample:\r\n\r\n\r\nInput: [3,1,5,8]\r\nOutput: 167 \r\nExplanation: nums = [3,1,5,8] --> [3,5,8] -->   [3,8]   -->  [8]  --> []\r\n             coins =  3*1*5      +  3*5*8    +  1*3*8      + 1*8*1   = 167\r\n"},{"index":85,"title":"Maximal Rectangle","body":{"mySolution":[],"optimizedSolution":[{"time":"$O(MN)$ where $M*N$ is the size of the matrix","space":"$O(N)$","code":"class Solution:\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\n        if len(matrix) == 0: return 0\n        for j in range(len(matrix[0])):\n            for i in range(len(matrix)):\n                if matrix[i][j] == '1':\n                    matrix[i][j] = matrix[i - 1][j] + 1 if i > 0 else 1\n                else:\n                    matrix[i][j] = 0\n        \n        max_size = 0\n        for i in range(len(matrix)):\n            row_max = self.maxRow(matrix[i])\n            max_size = max(max_size, row_max)\n        \n        return max_size\n    \n    def maxRow(self, row: List[int]) -> int:\n        row.append(0)\n        stack = [-1]\n        max_row = 0\n        for i in range(len(row)):\n            while row[i] < row[stack[-1]]:\n                h = row[stack.pop()]\n                w = i - stack[-1] - 1\n                max_row = max(max_row, h * w)\n            stack.append(i)\n        row.pop()\n        return max_row","language":"python"},{"time":"$O(MN)$","space":"$O(M)$","code":"class Solution:\n    def maximalRectangle(self, matrix: List[List[str]]) -> int:\n        if not matrix: return 0\n        m = len(matrix)\n        n = len(matrix[0])\n        h = [0] * n\n        l = [0] * n\n        r = [n] * n\n        max_area = 0\n        for i in range(m):\n            cur_left, cur_right = 0, n\n            for j in range(n - 1, -1, -1):\n                if matrix[i][j] == '1':\n                    r[j] = min(r[j], cur_right)\n                else:\n                    r[j] = n\n                    cur_right = j\n            for j in range(n):\n                if matrix[i][j] == '1':\n                    h[j] = h[j] + 1\n                    l[j] = max(l[j], cur_left)\n                else:\n                    h[j] = 0\n                    l[j] = 0\n                    cur_left = j + 1\n                max_area = max(max_area, h[j] * (r[j] - l[j]))\n        \n        return max_area","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/maximal-rectangle/","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [ ] can-optimize\n- [x] not-intuitive\n- [ ] bad-problem","Thinking":"I tried using a DFS search to look for rectangles but failed."},"desc":"Given a 2D binary matrix filled with 0's and 1's, find the largest rectangle containing only 1's and return its area.\r\n\r\nExample:\r\n\r\n\r\nInput:\r\n[\r\n  [\"1\",\"0\",\"1\",\"0\",\"0\"],\r\n  [\"1\",\"0\",\"1\",\"1\",\"1\"],\r\n  [\"1\",\"1\",\"1\",\"1\",\"1\"],\r\n  [\"1\",\"0\",\"0\",\"1\",\"0\"]\r\n]\r\nOutput: 6\r\n\r\n"},{"index":101,"title":"Symmetric Tree","body":{"mySolution":[{"time":"$O(2^N)$ where $N$ is the depth of the tree","space":"$O(2^N)$ due to the recursive stack","code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass Solution:\n    def isSymmetric(self, root: TreeNode) -> bool:\n        if not root: return True\n        return self.sym(root.left, root.right)\n    \n    def sym(self, left, right):\n        if left is None or right is None:\n            return left == right\n        return left.val == right.val and self.sym(left.left, right.right) and self.sym(left.right, right.left)","language":"python"}],"optimizedSolution":[{"time":"$O(2^N)$","space":"$O(2^N)$","code":"class Solution:\n    def isSymmetric(self, root: TreeNode) -> bool:\n        if not root: return True\n        stack = [root.left, root.right]\n        while len(stack) > 0:\n            t1 = stack.pop()\n            t2 = stack.pop()\n            if not t1 and not t2:\n                continue\n            if not t1 or not t2 or t1.val != t2.val:\n                return False\n            stack.extend([t1.left, t2.right, t2.left, t1.right])\n        return True","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/symmetric-tree/","Solved":"- [x] solved\n- [ ] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [ ] can-optimize\n- [x] not-intuitive\n- [ ] bad-problem","Thinking":"What I thought about this problem"},"desc":"Given a binary tree, check whether it is a mirror of itself (ie, symmetric around its center).\r\n\r\nFor example, this binary tree [1,2,2,3,4,4,3] is symmetric:\r\n\r\n\r\n    1\r\n   / \\\r\n  2   2\r\n / \\ / \\\r\n3  4 4  3\r\n\r\n\r\n \r\n\r\nBut the following [1,2,2,null,3,null,3] is not:\r\n\r\n\r\n    1\r\n   / \\\r\n  2   2\r\n   \\   \\\r\n   3    3\r\n\r\n\r\n \r\n\r\nNote:\r\nBonus points if you could solve it both recursively and iteratively.\r\n"},{"index":84,"title":"Largest Rectangle in Histogram","body":{"mySolution":[],"optimizedSolution":[{"time":"$O(N)$","space":"$O(N)$","code":"class Solution:\n    def largestRectangleArea(self, heights: List[int]) -> int:\n        heights.append(0)\n        stack = [-1]\n        ans = 0\n        for i in range(len(heights)):\n            while heights[i] < heights[stack[-1]]:\n                h = heights[stack.pop()]\n                w = i - stack[-1] - 1\n                ans = max(ans, h * w)\n            stack.append(i)\n        heights.pop()\n        return ans\n    ","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/largest-rectangle-in-histogram/","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [ ] can-optimize\n- [x] not-intuitive\n- [ ] bad-problem","Thinking":"I was thinking about using a sliding window to solve the problem but with no results."},"desc":"Given n non-negative integers representing the histogram's bar height where the width of each bar is 1, find the area of largest rectangle in the histogram.\r\n\r\n \r\n\r\n\r\nAbove is a histogram where width of each bar is 1, given height = [2,1,5,6,2,3].\r\n\r\n \r\n\r\n\r\nThe largest rectangle is shown in the shaded area, which has area = 10 unit.\r\n\r\n \r\n\r\nExample:\r\n\r\n\r\nInput: [2,1,5,6,2,3]\r\nOutput: 10\r\n\r\n"},{"index":66,"title":"Plus One","body":{"mySolution":[],"optimizedSolution":[],"anki":""},"desc":"Given a non-empty array of digits representing a non-negative integer, plus one to the integer.\r\n\r\nThe digits are stored such that the most significant digit is at the head of the list, and each element in the array contain a single digit.\r\n\r\nYou may assume the integer does not contain any leading zero, except the number 0 itself.\r\n\r\nExample 1:\r\n\r\n\r\nInput: [1,2,3]\r\nOutput: [1,2,4]\r\nExplanation: The array represents the integer 123.\r\n\r\n\r\nExample 2:\r\n\r\n\r\nInput: [4,3,2,1]\r\nOutput: [4,3,2,2]\r\nExplanation: The array represents the integer 4321.\r\n"},{"index":4,"title":"Median of Two Sorted Arrays","body":{"mySolution":[{"time":"$O(log(min(m, n))$","space":"$O(1)$","code":"class Solution:\n    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:\n        # Assume m <= n\n        if len(nums1) > len(nums2):\n            nums1, nums2 = nums2, nums1\n        m, n = len(nums1), len(nums2) \n        m_min, m_max = 0, m\n        mid = (m + n) // 2\n        m1, n1 = 0, 0\n        while m_min <= m_max:\n            m1 = (m_min + m_max) // 2\n            n1 = mid - m1\n            if n1 != 0 and m != m1 and nums2[n1 - 1] > nums1[m1]:\n                m_min = m1 + 1\n            elif m1 != 0 and n != n1 and nums1[m1 - 1] > nums2[n1]:\n                m_max = m1 - 1\n            else:\n                break\n\n        leftMax = 0\n        rightMin = 0\n        if m1 == m or n1 == n:\n            rightMin = nums2[n1] if m1 == m else nums1[m1]\n        else:\n            rightMin = min(nums1[m1], nums2[n1])\n\n        if (m + n) % 2 == 1: return rightMin\n\n        if m1 == 0 or n1 == 0:\n            leftMax = nums2[n1 - 1] if m1 == 0 else nums1[m1 - 1]\n        else:\n            leftMax = max(nums1[m1 - 1], nums2[n1 - 1])\n        \n        return (leftMax + rightMin) / 2","language":"python"},{"time":"$O(log(min(m, n))$","space":"$O(1)$","code":"class Solution {\npublic:\n    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {\n        // Make sure that m >= n\n        if (nums1.size() < nums2.size()) {\n            swap(nums1, nums2);\n        }\n        int m = nums1.size();\n        int n = nums2.size();\n        if (m == 0) {\n            return n % 2 == 0 ? (nums2[n / 2 - 1] + nums2[n / 2]) / 2.0 : nums2[n / 2];\n        }\n        if (n == 0) {\n            return m % 2 == 0 ? (nums1[m / 2 - 1] + nums1[m / 2]) / 2.0 : nums1[m / 2];\n        }\n        int half = (m + n) / 2;\n        int start = half - n;\n        int end = half;\n        int i, j;\n        while (start <= end) {\n            i = (start + end) / 2;\n            j = half - i;\n            if (j > 0 && i < m && nums2[j - 1] > nums1[i]) {\n                start = i + 1;\n                continue;\n            }\n            if (i > 0 && j < n && nums1[i - 1] > nums2[j]) {\n                end = i - 1;\n                continue;\n            }\n            break;\n        }\n        int leftMax, rightMin;\n        if (i == m || j == n) {\n            rightMin = (i == m) ? nums2[j] : nums1[i];\n        }\n        else{\n            rightMin = min(nums1[i], nums2[j]);    \n        }\n        if ((m + n) % 2 == 1) {\n            return rightMin;\n        }\n        if (i == 0 || j == 0) {\n            leftMax = (i == 0) ? nums2[j - 1] : nums1[i - 1];\n        }\n        else {\n            leftMax = max(nums1[i - 1], nums2[j - 1]);\n        }\n        return (leftMax + rightMin) / 2.0;\n    }\n};","language":"cpp"}],"optimizedSolution":[{"time":"$O(log(min(m, n))$","space":"$O(1)$","code":"...\n# Line 13\n          if m1 < m and nums2[n1 - 1] > nums1[m1]:\n              m_min = m1 + 1\n          elif m1 > 0 and nums1[m1 - 1] > nums2[n1]:\n              m_max = m1 - 1\n          else:\n              break\n...","language":"python"}],"anki":"Binary search in the longer array. Watch for corner cases and the start and end of search range.","Link":"https://leetcode.com/problems/median-of-two-sorted-arrays/","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [x] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem","Test Cases":"* [1,2], [3,4]\n* [], [1]\n* [1], [2,3,4,5,6]"},"desc":"There are two sorted arrays nums1 and nums2 of size m and n respectively.\r\n\r\nFind the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).\r\n\r\nYou may assume nums1 and nums2 cannot be both empty.\r\n\r\nExample 1:\r\n\r\n\r\nnums1 = [1, 3]\r\nnums2 = [2]\r\n\r\nThe median is 2.0\r\n\r\n\r\nExample 2:\r\n\r\n\r\nnums1 = [1, 2]\r\nnums2 = [3, 4]\r\n\r\nThe median is (2 + 3)/2 = 2.5\r\n\r\n"},{"index":155,"title":"Min Stack","body":{"mySolution":[{"time":"$O(1)$","space":"$O(N)$","code":"class MinStack:\n    def __init__(self):\n        \"\"\n        initialize your data structure here.\n        \"\"\"\n        self.list = []\n        self.minList = []\n        \n\n    def push(self, x: int) -> None:\n        self.list.append(x)\n        if len(self.minList) == 0 or x < self.minList[-1]:\n            self.minList.append(x)\n        else:\n            self.minList.append(self.minList[-1])\n        \n    def pop(self) -> None:\n        self.list.pop()\n        self.minList.pop()\n\n    def top(self) -> int:\n        return None if len(self.list) == 0 else self.list[-1]\n\n    def getMin(self) -> int:\n        return None if len(self.minList) == 0 else self.minList[-1]","language":"python"}],"optimizedSolution":[{"time":"$O(1)$","space":"$O(N)$","code":"class MinStack:\n    def __init__(self):\n        \"\"\"\n        initialize your data structure here.\n        \"\"\"\n        self.list = []\n        self.min = float('inf')\n        \n\n    def push(self, x: int) -> None:\n        if x <= self.min:\n            self.list.append(self.min)\n            self.min = x\n        self.list.append(x)\n        \n    def pop(self) -> None:\n        if self.list.pop() == self.min:\n            self.min = self.list.pop()\n\n    def top(self) -> int:\n        return self.list[-1]\n\n    def getMin(self) -> int:\n        return self.min","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/min-stack/","Solved":"- [x] solved\n- [ ] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [x] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem","Thinking":"What I thought about this problem"},"desc":"Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.\r\n\r\n\r\n\tpush(x) -- Push element x onto stack.\r\n\tpop() -- Removes the element on top of the stack.\r\n\ttop() -- Get the top element.\r\n\tgetMin() -- Retrieve the minimum element in the stack.\r\n\r\n\r\n \r\n\r\nExample:\r\n\r\n\r\nMinStack minStack = new MinStack();\r\nminStack.push(-2);\r\nminStack.push(0);\r\nminStack.push(-3);\r\nminStack.getMin();   --> Returns -3.\r\nminStack.pop();\r\nminStack.top();      --> Returns 0.\r\nminStack.getMin();   --> Returns -2.\r\n\r\n\r\n \r\n"},{"index":124,"title":"Binary Tree Maximum Path Sum","body":{"mySolution":[],"optimizedSolution":[{"time":"$O(N)$ where $N$ is the number of nodes in the tree","space":"$O(H)$ where $H$ is the height of the tree","code":"class Solution:\n    def maxPathSum(self, root: TreeNode) -> int:\n        max_sum = float('-inf')\n        def max_gain(root):\n            nonlocal max_sum\n            if not root: return 0\n            max_left = max(max_gain(root.left), 0)\n            max_right = max(max_gain(root.right), 0)\n            max_sum = max(max_sum, root.val + max_left + max_right)\n            return root.val + max(max_left, max_right)\n        max_gain(root)\n        return max_sum","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/binary-tree-maximum-path-sum/","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [ ] can-optimize\n- [x] not-intuitive\n- [ ] bad-problem"},"desc":"Given a non-empty binary tree, find the maximum path sum.\r\n\r\nFor this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.\r\n\r\nExample 1:\r\n\r\n\r\nInput: [1,2,3]\r\n\r\n       1\r\n      / \\\r\n     2   3\r\n\r\nOutput: 6\r\n\r\n\r\nExample 2:\r\n\r\n\r\nInput: [-10,9,20,null,null,15,7]\r\n\r\n   -10\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7\r\n\r\nOutput: 42\r\n\r\n"},{"index":142,"title":"Linked List Cycle II","body":{"mySolution":[],"optimizedSolution":[{"time":"$O(N)$","space":"$O(1)$","code":"class Solution(object):\n    def detectCycle(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        slow = fast = head\n        while fast and slow:\n            if not fast.next: return None\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow:\n                return self.findEntrance(head, fast)\n        return None\n    \n    def findEntrance(self, head, intersect):\n        while head != intersect:\n            head = head.next\n            intersect = intersect.next\n        return head","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/linked-list-cycle-ii/","Solved":"- [ ] solved\n- [ ] by-discussion\n- [x] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [ ] can-optimize\n- [x] not-intuitive\n- [ ] bad-problem","Thinking":"Completely no idea except for modifying the list"},"desc":"Given a linked list, return the node where the cycle begins. If there is no cycle, return null.\n\nTo represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.\n\nNote: Do not modify the linked list.\n\n \n\nExample 1:\n\n\nInput: head = [3,2,0,-4], pos = 1\nOutput: tail connects to node index 1\nExplanation: There is a cycle in the linked list, where tail connects to the second node.\n\n\n\n\nExample 2:\n\n\nInput: head = [1,2], pos = 0\nOutput: tail connects to node index 0\nExplanation: There is a cycle in the linked list, where tail connects to the first node.\n\n\n\n\nExample 3:\n\n\nInput: head = [1], pos = -1\nOutput: no cycle\nExplanation: There is no cycle in the linked list.\n\n\n\n\n \n\nFollow-up:\nCan you solve it without using extra space?\n"},{"index":57,"title":"Insert Interval","body":{"mySolution":[],"optimizedSolution":[],"anki":""},"desc":"Given a set of non-overlapping intervals, insert a new interval into the intervals (merge if necessary).\r\n\r\nYou may assume that the intervals were initially sorted according to their start times.\r\n\r\nExample 1:\r\n\r\n\r\nInput: intervals = [[1,3],[6,9]], newInterval = [2,5]\r\nOutput: [[1,5],[6,9]]\r\n\r\n\r\nExample 2:\r\n\r\n\r\nInput: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8]\r\nOutput: [[1,2],[3,10],[12,16]]\r\nExplanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\r\n\r\nNOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.\r\n"},{"index":43,"title":"Multiply Strings","body":{"mySolution":[],"optimizedSolution":[],"anki":""},"desc":"Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.\r\n\r\nExample 1:\r\n\r\n\r\nInput: num1 = \"2\", num2 = \"3\"\r\nOutput: \"6\"\r\n\r\nExample 2:\r\n\r\n\r\nInput: num1 = \"123\", num2 = \"456\"\r\nOutput: \"56088\"\r\n\r\n\r\nNote:\r\n\r\n\r\n\tThe length of both num1 and num2 is < 110.\r\n\tBoth num1 and num2 contain only digits 0-9.\r\n\tBoth num1 and num2 do not contain any leading zero, except the number 0 itself.\r\n\tYou must not use any built-in BigInteger library or convert the inputs to integer directly.\r\n\r\n"},{"index":15,"title":"3Sum","body":{"mySolution":[{"time":"$O(N^2log(N))$","space":"$O(1)$","code":"class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        if not nums:\n            return []\n        nums.sort()\n        res = []\n        # Use two pointers and binary search for the third one\n        for l in range(0, len(nums) - 2):\n            if l > 0 and nums[l] == nums[l - 1]:\n                continue\n            for r in range(len(nums) - 1, l + 1, -1):\n                if r < len(nums) - 1 and nums[r] == nums[r + 1]:\n                    continue\n                \n                target = -nums[r] - nums[l]\n                \n                # If target is greater than the right element, since the target will increase when r decreases\n                # we do not need to search further\n                if target > nums[r]:\n                    break\n                \n                if target < nums[l]:\n                    continue\n                \n                start, end = l + 1, r - 1\n                while start <= end:\n                    m = (start + end) // 2\n                    if nums[m] == target:\n                        res.append([nums[l], nums[m], nums[r]])\n                        break\n                    elif nums[m] < target:\n                        start = m + 1\n                    else:\n                        end = m - 1\n                 \n        return res","language":"python"}],"optimizedSolution":[{"time":"$O(N^2)$","space":"$O(1)$","code":"class Solution:\n    def threeSum(self, nums: List[int]) -> List[List[int]]:\n        if not nums:\n            return []\n        nums.sort()\n        res = []\n        for i in range(len(nums) - 2):\n            if i > 0 and nums[i] == nums[i - 1]:\n                continue\n            l = i + 1\n            r = len(nums) - 1\n            while l < r:\n                s = nums[i] + nums[l] + nums[r]\n                if s < 0:\n                    l += 1\n                elif s > 0:\n                    r -= 1\n                else:\n                    res.append([nums[i], nums[l], nums[r]])\n                    l += 1\n                    r -= 1\n                    while l < r and nums[l] == nums[l - 1]:\n                        l += 1\n                    while l < r and nums[r] == nums[r + 1]:\n                        r -= 1\n                 \n        return res","language":"python"}],"anki":"Sort first. Use two pointers to approach to the middle. Use a while loop to avoid repetitive solution.","Link":"https://leetcode.com/problems/3sum/","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [x] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem"},"desc":"Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.\r\n\r\nNote:\r\n\r\nThe solution set must not contain duplicate triplets.\r\n\r\nExample:\r\n\r\n\r\nGiven array nums = [-1, 0, 1, 2, -1, -4],\r\n\r\nA solution set is:\r\n[\r\n  [-1, 0, 1],\r\n  [-1, -1, 2]\r\n]\r\n\r\n"},{"index":297,"title":"Serialize and Deserialize Binary Tree","body":{"mySolution":[{"time":"$O(N)$","space":"$O(N)$","code":"from collections import deque\n\n# Same codec with leetcode implementation\nclass Codec:\n\n    def serialize(self, root):\n        \"\"\"Encodes a tree to a single string.\n        \n        :type root: TreeNode\n        :rtype: str\n        \"\"\"\n        res = []\n        q = deque([root])\n        while q:\n            n = q.popleft()\n            res.append(n.val if n else None) \n            if n:\n                q.append(n.left)\n                q.append(n.right)\n        \n        i = len(res) - 1\n        while i > -1 and res[i] == 'n': i -= 1\n        return str(res[:i + 1])\n            \n        \n\n    def deserialize(self, data):\n        \"\"\"Decodes your encoded data to tree.\n        \n        :type data: str\n        :rtype: TreeNode\n        \"\"\"\n        if not data: return None\n        \n        l = data[1:-1].split(',')\n        \n        def toNode(c):\n            c = c.strip()\n            if c == 'None':\n                return None\n            elif c[0] == '-':\n                return TreeNode(int(c[1:]) * -1)\n            return TreeNode(int(c))\n        \n        root = toNode(l[0])\n        q = deque([root])\n        i = 1\n        isRight = False\n        n = None\n        \n        while i < len(l):\n            if not isRight:\n                n = q.popleft()\n                while n is None:\n                    n = q.popleft()\n                n.left = toNode(l[i])\n                i += 1\n                isRight = True\n            else:\n                n.right = toNode(l[i])\n                i += 1\n                isRight = False\n                q.append(n.left)\n                q.append(n.right)\n        \n        return root\n        ","language":"python"}],"optimizedSolution":[{"time":"$O(N)$","space":"$O(N^2)$","code":"Post the optimized solution after looking at the solution. ","language":""}],"anki":"","Link":"https://leetcode.com/problems/serialize-and-deserialize-binary-tree/","Solved":"- [x] solved\n- [ ] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [x] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem","Thinking":""},"desc":"Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.\r\n\r\nDesign an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.\r\n\r\nExample: \r\n\r\n\r\nYou may serialize the following tree:\r\n\r\n    1\r\n   / \\\r\n  2   3\r\n     / \\\r\n    4   5\r\n\r\nas \"[1,2,3,null,null,4,5]\"\r\n\r\n\r\nClarification: The above format is the same as how LeetCode serializes a binary tree. You do not necessarily need to follow this format, so please be creative and come up with different approaches yourself.\r\n\r\nNote: Do not use class member/global/static variables to store states. Your serialize and deserialize algorithms should be stateless.\r\n"},{"index":438,"title":"Find All Anagrams in a String","body":{"mySolution":[{"time":"$O(N)$","space":"$O(N)$","code":"class Solution:\n    def findAnagrams(self, s: str, p: str) -> List[int]:\n        res = []\n        # count stores the count of numbers in p\n        count = {}\n        # matched stores the number of letters in our sliding window that has the same count as p\n        matched = 0\n\n        if len(s) < len(p):\n            return res\n        \n        for c in p:\n            count[c] = count.get(c, 0) + 1\n            \n        for i in range(len(p)):\n            c = s[i]\n            if c in count:\n                count[c] -= 1\n                matched += count[c] == 0\n                matched -= count[c] < 0\n        \n        start = 0\n        end = start + len(p) - 1\n        \n        while end < len(s):\n            if matched == len(count.keys()):\n                res.append(start)\n            \n            if s[start] in count:\n                count[s[start]] += 1\n                matched -= count[s[start]] == 1\n                matched += count[s[start]] == 0\n            \n            start += 1\n            end += 1\n\n            if end < len(s) and s[end] in count:\n                count[s[end]] -= 1\n                matched -= count[s[end]] == -1\n                matched += count[s[end]] == 0\n            \n        return res","language":"python"}],"optimizedSolution":[{"time":"$O(N)$","space":"$O(N)$","code":"class Solution:\n    # much cleaner code\n    def findAnagrams(self, s: str, p: str) -> List[int]:\n        res = []\n        count = {}\n        matched = 0\n\n        if len(s) < len(p):\n            return res\n        \n        for c in p:\n            count[c] = count.get(c, 0) + 1\n            \n        def changeCount(c, num):\n            if c not in count:\n                return\n            nonlocal matched\n            matched -= count[c] == 0\n            count[c] += num\n            matched += count[c] == 0\n            \n        for i in range(len(p)):\n            changeCount(s[i], -1)\n\n        if matched == len(count.keys()):\n            res.append(0)\n        \n        start = 1\n        while start + len(p) - 1 < len(s):\n            changeCount(s[start - 1], 1)\n            changeCount(s[start + len(p) - 1], -1)\n            if matched == len(count.keys()):\n                res.append(start)\n            start += 1\n                \n        return res","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/find-all-anagrams-in-a-string/","Solved":"- [x] solved\n- [ ] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [x] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem","Thinking":"What I thought about this problem"},"desc":"Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.\r\n\r\nStrings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.\r\n\r\nThe order of output does not matter.\r\n\r\nExample 1:\r\n\r\nInput:\r\ns: \"cbaebabacd\" p: \"abc\"\r\n\r\nOutput:\r\n[0, 6]\r\n\r\nExplanation:\r\nThe substring with start index = 0 is \"cba\", which is an anagram of \"abc\".\r\nThe substring with start index = 6 is \"bac\", which is an anagram of \"abc\".\r\n\r\n\r\n\r\nExample 2:\r\n\r\nInput:\r\ns: \"abab\" p: \"ab\"\r\n\r\nOutput:\r\n[0, 1, 2]\r\n\r\nExplanation:\r\nThe substring with start index = 0 is \"ab\", which is an anagram of \"ab\".\r\nThe substring with start index = 1 is \"ba\", which is an anagram of \"ab\".\r\nThe substring with start index = 2 is \"ab\", which is an anagram of \"ab\".\r\n\r\n"},{"index":42,"title":"Trapping Rain Water","body":{"mySolution":[],"optimizedSolution":[{"time":"$O(N)$","space":"$O(N)$ worst case for a decreasing list","code":"class Solution:\n    def trap(self, height: List[int]) -> int:\n        if not height:\n            return 0\n        s = 0\n        stack = []\n        for i in range(len(height)):\n            while stack and height[stack[-1]] < height[i]:\n                top = stack.pop()\n                if not stack:\n                    break\n                s += (i - stack[-1] - 1) * (min(height[i], height[stack[-1]]) - height[top])\n            stack.append(i)\n        return s","language":"python"},{"time":"$O(N)$","space":"$O(N)$","code":"class Solution:\n    # Dynamic programming\n    def trap(self, height: List[int]) -> int:\n        if not height:\n            return 0\n        s = 0\n        maxleft = [0] * len(height)\n        maxright = [0] * len(height)\n        maxleft[0] = height[0]\n        for i in range(1, len(height)):\n            maxleft[i] = max(maxleft[i - 1], height[i])\n        maxright[-1] = height[-1]\n        for i in range(len(height) - 2, -1, -1):\n            maxright[i] = max(maxright[i + 1], height[i])\n        for i in range(len(height)):\n            s += min(maxleft[i], maxright[i]) - height[i]\n        return s","language":"python"},{"time":"$O(N)$","space":"$O(1)$","code":"class Solution:\n    def trap(self, height: List[int]) -> int:\n        s = 0\n        left = 0\n        right = len(height) - 1\n        left_max = right_max = 0\n        while left < right:\n            # If height[left] < height[right],\n            # that means height[left] < min(left_max, right_max)\n            # so the increasing size would only be depending on the left max\n            # Same for the right side. \n            if height[left] < height[right]:\n                left_max = max(height[left], left_max)\n                s += left_max - height[left]\n                left += 1\n            else:\n                right_max = max(height[right], right_max)\n                s += right_max - height[right]\n                right -= 1\n        return s","language":"python"}],"anki":"Three methods can be used to solve this problem. And all three can be done within linear time.\n1. Using stack. We are tring to catch the 'V' pattern in the histogram. And a stack is used to store the left side of 'V'. We ignore the case when decreasing or increasing when stack is empty. For the other cases, the water that a column can retain is calculated by the vertical bar formed with the left bounds that are smaller than it.\n2. Dynamic programming. Suppose you're standing on one of the bar. Look left, the highest bar is `maxleft[i]`. The `maxright[i]` is defined the same. The water that can finally be \"stored\" on top of the bar is decided by the minimum of the left/right boundary. So we store the `maxleft` and `maxright` at each bar. And accumulate the value by using `min(left, right) - height[i]`.\n3. Method 2 can be optimized by only using constant space and two pointers. Use `maxleft` and `maxright` to store the maximum up to now. When `height[left] < height[right]`, `height[left]` is able to keep water if `maxleft > height[left]`. So we accululate the `maxleft - height[left]` each time. Same for the right side.","Link":"https://leetcode.com/problems/trapping-rain-water/","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [x] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem"},"desc":"Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.\r\n\r\n\r\nThe above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!\r\n\r\nExample:\r\n\r\n\r\nInput: [0,1,0,2,1,0,1,3,2,1,2,1]\r\nOutput: 6\r\n"},{"index":1038,"title":"Binary Search Tree to Greater Sum Tree","body":{"mySolution":[],"optimizedSolution":[],"anki":""},"desc":"Given the root of a binary search tree with distinct values, modify it so that every node has a new value equal to the sum of the values of the original tree that are greater than or equal to node.val.\r\n\r\nAs a reminder, a binary search tree is a tree that satisfies these constraints:\r\n\r\n\r\n\tThe left subtree of a node contains only nodes with keys less than the node's key.\r\n\tThe right subtree of a node contains only nodes with keys greater than the node's key.\r\n\tBoth the left and right subtrees must also be binary search trees.\r\n\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\n\r\n\r\nInput: [4,1,6,0,2,5,7,null,null,null,3,null,null,null,8]\r\nOutput: [30,36,21,36,35,26,15,null,null,null,33,null,null,null,8]\r\n\r\n\r\n\r\n \r\n\r\n\r\nNote:\r\n\r\n\r\n\tThe number of nodes in the tree is between 1 and 100.\r\n\tEach node will have value between 0 and 100.\r\n\tThe given tree is a binary search tree.\r\n\r\n\r\n\r\n\r\n \r\n\r\n\r\n"},{"index":301,"title":"Remove Invalid Parentheses","body":{"mySolution":[{"time":"","space":"","code":"","language":""}],"optimizedSolution":[{"time":"$O(2^N)$ in worst case for example '(((((('","space":"$O(N)$ maximum recursion depth is $N$ as well as the size of the expr list","code":"class Solution:\n    def removeInvalidParentheses(self, s):\n        left = 0\n        right = 0\n\n        # Determine the number of left and right bracket to remove\n        # used for pruning the recursion tree later\n  \n        for i in s:\n            if i == '(':\n                left += 1\n            elif i == ')':\n                if left > 0:\n                    left -= 1\n                else:\n                    right += 1\n        \n        res = set()\n        expr = []\n        \n        def rec(ind, left_rem, right_rem, left_count, right_count):\n            if ind == len(s):\n                # The expression is valid if the unvalid brackets are removed\n                if left_rem == 0 and right_rem == 0:\n                    valid_str = ''.join(expr)\n                    res.add(valid_str)\n                return\n            \n            char = s[ind]\n            ind += 1\n            \n            # Case 1. we remove the current bracket\n            if (char == '(' and left_rem > 0) or (char == ')' and right_rem > 0):\n                rec(ind, left_rem - (char == '('), right_rem - (char == ')'), left_count, right_count)\n\n            expr.append(char)\n            \n            # Case 2. we keep the current bracket or any other character\n            if char == '(':\n                rec(ind, left_rem, right_rem, left_count + 1, right_count)\n            elif char == ')' and left_count > right_count:\n                rec(ind, left_rem, right_rem, left_count, right_count + 1)\n            elif char != ')' and char != '(':\n                rec(ind, left_rem, right_rem, left_count, right_count)\n            \n            # Pop the current char for backtracking\n            expr.pop(-1)\n            \n        rec(0, left, right, 0, 0)\n        return list(res)","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/remove-invalid-parentheses/","Solved":"- [ ] solved\n- [ ] by-discussion\n- [x] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [x] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem","Thinking":""},"desc":"Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.\r\n\r\nNote: The input string may contain letters other than the parentheses ( and ).\r\n\r\nExample 1:\r\n\r\n\r\nInput: \"()())()\"\r\nOutput: [\"()()()\", \"(())()\"]\r\n\r\n\r\nExample 2:\r\n\r\n\r\nInput: \"(a)())()\"\r\nOutput: [\"(a)()()\", \"(a())()\"]\r\n\r\n\r\nExample 3:\r\n\r\n\r\nInput: \")(\"\r\nOutput: [\"\"]\r\n"},{"index":167,"title":"Two Sum II - Input array is sorted","body":{"mySolution":[{"time":"$O(Nlog(N)$ or $O(N-1) + O(N-2) + ... + O(1) = O((N-1)!)$","space":"$O(1)$","code":"class Solution:\n    # Binary search\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        for i in range(len(numbers) - 1):\n            if i > 0 and numbers[i] == numbers[i - 1]:\n                continue\n            start = i + 1\n            end = len(numbers) - 1\n            if numbers[end] < target - numbers[i]:\n                continue\n            while start <= end:\n                mid = (start + end) // 2\n                if numbers[mid] == target - numbers[i]:\n                    return [i + 1, mid + 1]\n                elif numbers[mid] < target - numbers[i]:\n                    start = mid + 1\n                else:\n                    end = mid - 1","language":"python"}],"optimizedSolution":[{"time":"$O(N)$","space":"$O(1)$","code":"class Solution:\n    # Two pointers\n    # Since we only need to find one solution and this solution is guranteed to exist, we can use two pointers\n    # This solution cannot work if we're going to find all solutions\n    def twoSum(self, numbers: List[int], target: int) -> List[int]:\n        l, r = 0, len(numbers) - 1\n        while l < r:\n            s = numbers[l] + numbers[r]\n            if s == target:\n                return [l + 1, r + 1]\n            elif s < target:\n                l += 1\n                while numbers[l] == numbers[l - 1]:\n                    l += 1\n            else:\n                r -= 1\n                while numbers[r] == numbers[r + 1]:\n                    r -= 1","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/","Solved":"- [x] solved\n- [ ] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [x] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem","Thinking":""},"desc":"Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.\r\n\r\nThe function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.\r\n\r\nNote:\r\n\r\n\r\n\tYour returned answers (both index1 and index2) are not zero-based.\r\n\tYou may assume that each input would have exactly one solution and you may not use the same element twice.\r\n\r\n\r\nExample:\r\n\r\n\r\nInput: numbers = [2,7,11,15], target = 9\r\nOutput: [1,2]\r\nExplanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.\r\n"},{"index":148,"title":"Sort List","body":{"mySolution":[],"optimizedSolution":[{"time":"$O(NlgN)$","space":"$O(1)$","code":"class Solution:\n    def sortList(self, head: ListNode) -> ListNode:\n        # Find the length of the list\n        l = 0\n        node = head\n        while node:\n            l += 1\n            node = node.next\n        step = 1\n        dummy = ListNode(0)\n        dummy.next = head\n        while step < l:\n            left = dummy.next\n            tail = dummy\n            while left:\n                right = self.split(left, step)\n                nextLeft = self.split(right, step)\n                tail = self.merge(left, right, tail)\n                left = nextLeft\n                tail.next = left\n            step *= 2\n        return dummy.next\n    \n    def split(self, head, length):\n        # Split a list of length from head, set tail.next to be None\n        if not head: return None\n        i = 1\n        while head.next and i < length:\n            head = head.next\n            i += 1\n        \n        n = head.next\n        head.next = None\n        return n\n    \n    def merge(self, left, right, tail):\n        # Merge left and right and append the merged list to tail\n        # Return the merged tail\n        while left and right:\n            if left.val < right.val:\n                tail.next = left\n                left = left.next\n            else:\n                tail.next = right\n                right = right.next\n            tail = tail.next\n        \n        tail.next = left if left else right\n        while tail.next: tail = tail.next\n        return tail","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/sort-list/","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [ ] can-optimize\n- [x] not-intuitive\n- [ ] bad-problem"},"desc":"Sort a linked list in O(n log n) time using constant space complexity.\r\n\r\nExample 1:\r\n\r\n\r\nInput: 4->2->1->3\r\nOutput: 1->2->3->4\r\n\r\n\r\nExample 2:\r\n\r\n\r\nInput: -1->5->3->4->0\r\nOutput: -1->0->3->4->5\r\n"},{"index":33,"title":"Search in Rotated Sorted Array","body":{"mySolution":[],"optimizedSolution":[],"anki":""},"desc":"Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.\r\n\r\n(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).\r\n\r\nYou are given a target value to search. If found in the array return its index, otherwise return -1.\r\n\r\nYou may assume no duplicate exists in the array.\r\n\r\nYour algorithm's runtime complexity must be in the order of O(log n).\r\n\r\nExample 1:\r\n\r\n\r\nInput: nums = [4,5,6,7,0,1,2], target = 0\r\nOutput: 4\r\n\r\n\r\nExample 2:\r\n\r\n\r\nInput: nums = [4,5,6,7,0,1,2], target = 3\r\nOutput: -1\r\n"},{"index":221,"title":"Maximal Square","body":{"mySolution":[],"optimizedSolution":[{"time":"$O(MN)$ where $M*N$ is the size of the matrix","space":"$O(MN)$","code":"class Solution:\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\n        if not matrix: return 0\n        n = len(matrix)\n        m = len(matrix[0])\n        dp = [([0] * m) for _ in range(n)]\n        max_len = 0\n        for i in range(n):\n            for j in range(m):\n                if matrix[i][j] == '0': continue\n                a = dp[i][j - 1] if j > 0 else 0\n                b = dp[i - 1][j] if i > 0 else 0\n                c = dp[i - 1][j - 1] if i > 0 and j > 0 else 0\n                dp[i][j] = min(a, b, c) + 1\n                max_len = max(max_len, dp[i][j])\n        return max_len * max_len","language":"python"},{"time":"$O(MN)$","space":"$O(min(M, N))$","code":"class Solution:\n    def maximalSquare(self, matrix: List[List[str]]) -> int:\n        if not matrix: return 0\n        m = len(matrix[0])\n        dp = [0] * m\n        max_len = 0\n        last = 0\n        for i in range(len(matrix)):\n            for j in range(m):\n                if matrix[i][j] == '0':\n                    dp[j] = 0\n                else:\n                    dp[j], last = min(dp[j - 1] if j > 0 else 0, dp[j], last) + 1, dp[j]\n                max_len = max(max_len, dp[j])\n        return max_len * max_len\n","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/maximal-square/","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [x] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem","Thinking":""},"desc":"Given a 2D binary matrix filled with 0's and 1's, find the largest square containing only 1's and return its area.\r\n\r\nExample:\r\n\r\n\r\nInput: \r\n\r\n1 0 1 0 0\r\n1 0 1 1 1\r\n1 1 1 1 1\r\n1 0 0 1 0\r\n\r\nOutput: 4\r\n"},{"index":165,"title":"Compare Version Numbers","body":{"mySolution":[{"time":"$O(N)$","space":"$O(N)$","code":"class Solution:\n    def compareVersion(self, version1: str, version2: str) -> int:\n        arr1 = version1.split('.')\n        arr2 = version2.split('.')\n        flag = 1\n        if len(arr2) > len(arr1):\n            arr1, arr2 = arr2, arr1\n            flag = -1\n        \n        for i in range(len(arr2)):\n            v1 = int(arr1[i])\n            v2 = int(arr2[i])\n            if v1 > v2:\n                return flag\n            if v1 < v2:\n                return -1 * flag\n        \n        for i in range(len(arr2), len(arr1)):\n            if int(arr1[i]) > 0:\n                return 1 * flag\n\n        return 0","language":"python"}],"optimizedSolution":[{"time":"$O(N)$","space":"$O(1)$","code":"class Solution:\n    def compareVersion(self, version1: str, version2: str) -> int:\n        i = j = 0\n        while i < len(version1) or j < len(version2):\n            num1 = num2 = 0\n            while i < len(version1) and version1[i] != '.':\n                num1 = 10 * num1 + ord(version1[i]) - ord('0')\n                i += 1\n            while j < len(version2) and version2[j] != '.':\n                num2 = 10 * num2 + ord(version2[j]) - ord('0')\n                j += 1\n            \n            if num1 > num2:\n                return 1\n            if num1 < num2:\n                return -1\n            \n            i += 1\n            j += 1\n            \n        return 0","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/compare-version-numbers/","Solved":"- [x] solved\n- [ ] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [ ] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem"},"desc":"Compare two version numbers version1 and version2.\r\nIf version1 > version2 return 1; if version1 < version2 return -1;otherwise return 0.\r\n\r\nYou may assume that the version strings are non-empty and contain only digits and the . character.\r\nThe . character does not represent a decimal point and is used to separate number sequences.\r\nFor instance, 2.5 is not \"two and a half\" or \"half way to version three\", it is the fifth second-level revision of the second first-level revision.\r\nYou may assume the default revision number for each level of a version number to be 0. For example, version number 3.4 has a revision number of 3 and 4 for its first and second level revision number. Its third and fourth level revision number are both 0.\r\n\r\n \r\n\r\nExample 1:\r\n\r\nInput: version1 = \"0.1\", version2 = \"1.1\"\r\nOutput: -1\r\n\r\nExample 2:\r\n\r\nInput: version1 = \"1.0.1\", version2 = \"1\"\r\nOutput: 1\r\n\r\nExample 3:\r\n\r\nInput: version1 = \"7.5.2.4\", version2 = \"7.5.3\"\r\nOutput: -1\r\n\r\nExample 4:\r\n\r\nInput: version1 = \"1.01\", version2 = \"1.001\"\r\nOutput: 0\r\nExplanation: Ignoring leading zeroes, both “01” and “001\" represent the same number “1”\r\n\r\nExample 5:\r\n\r\nInput: version1 = \"1.0\", version2 = \"1.0.0\"\r\nOutput: 0\r\nExplanation: The first version number does not have a third level revision number, which means its third level revision number is default to \"0\"\r\n\r\n \r\n\r\nNote:\r\n\r\nVersion strings are composed of numeric strings separated by dots . and this numeric strings may have leading zeroes. \r\nVersion strings do not start or end with dots, and they will not be two consecutive dots.\r\n"},{"index":399,"title":"Evaluate Division","body":{"mySolution":[{"time":"$O(N)$","space":"$O(N)$","code":"class Solution:\n    \n    # Solve the relationships stored in a dict\n    def solveDict(self, db, known_var, value, from_var):\n        # We add the variable `from_var` to prevent recursion, for example,\n        # db['d'] = { f: 2.0 }\n        # db['f'] = { d: 0.5 }\n        for var, times in db[known_var].items():\n            if from_var == var or known_var == var:\n                continue\n            if var not in db:\n                db[var] = value / times\n            elif type(db.get(var)) == dict:\n                self.solveDict(db, var, value / times, known_var)\n        db[known_var] = value\n            \n    # If we already have results for x, either\n    # 1. If x is a float, we can solve for y\n    # 2. If x is a dict, we add the relations for y into the dict\n    def assignVar(self, db, x, y, v):\n        if type(db[x]) == dict:\n            db[x][y] = v\n            db[y] = { x: 1/v }\n        else:\n            db[y] = db[x] / v\n        \n    def calcEquation(self, equations: List[List[str]], values: List[float], queries: List[List[str]]) -> List[float]:\n        db = dict()\n        # Set a reference variable\n        db[equations[0][1]] = 1.0\n        for i in range(len(equations)):\n            x, y = equations[i]\n            v = values[i]\n            # If both variables have not been recorded,\n            # we save the relative relations in a dict.\n            # Also the dict has a reference to it self,\n            # in order to distinguish variables that have never shown up\n            if x not in db and y not in db:\n                db[x] = { y: v, x: 1.0 }\n                db[y] = { x: 1/v, y: 1.0 }\n            # Both have been recorded\n            elif x in db and y in db:\n                if type(db[x]) == float and type(db[y]) == float:\n                    continue\n                # If either value is a dict,\n                # we can solve for the variables stored in the dict\n                elif type(db[x]) == float:\n                    self.solveDict(db, y, db[x] / v, None)\n                elif type(db[y]) == float:\n                    self.solveDict(db, x, db[y] * v, None)\n            elif x in db:\n                self.assignVar(db, x, y, v)               \n            elif y in db:\n                self.assignVar(db, y, x, 1 / v)\n                \n        res = [0] * len(queries) \n        for i in range(len(queries)):\n            x, y = queries[i]\n            \n            # If we know both variables as floats\n            if type(db.get(x)) == float and type(db.get(y)) == float:\n                res[i] = db[x] / db[y]\n            # If we only know the relative relationship(dict)\n            # we look for the variable in the dict\n            elif type(db.get(x)) == dict and y in db[x]:\n                res[i] = db[x][y]\n            elif type(db.get(y)) == dict and x in db[y]:\n                res[i] = 1 / db[y][x]\n            # Else we don't know the result\n            else:\n                res[i] = -1.0\n                \n        return res","language":"python"}],"optimizedSolution":[{"time":"$O(E + V)$ where $E$ is the number of edges and $V$ is the number of vertices","space":"$O(E)$","code":"class Solution(object):\n    def calcEquation(self, equations, values, queries):\n\n        graph = {}\n        \n        def build_graph(equations, values):\n            def add_edge(f, t, value):\n                if f in graph:\n                    graph[f].append((t, value))\n                else:\n                    graph[f] = [(t, value)]\n            \n            for vertices, value in zip(equations, values):\n                f, t = vertices\n                add_edge(f, t, value)\n                add_edge(t, f, 1/value)\n        \n        def find_path(query):\n            b, e = query\n            \n            if b not in graph or e not in graph:\n                return -1.0\n                \n            q = collections.deque([(b, 1.0)])\n            visited = set()\n            \n            while q:\n                front, cur_product = q.popleft()\n                if front == e:\n                    return cur_product\n                visited.add(front)\n                for neighbor, value in graph[front]:\n                    if neighbor not in visited:\n                        q.append((neighbor, cur_product*value))\n            \n            return -1.0\n        \n        build_graph(equations, values)\n        return [find_path(q) for q in queries]","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/evaluate-division/","Solved":"- [x] solved\n- [ ] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [x] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem","Thinking":""},"desc":"Equations are given in the format A / B = k, where A and B are variables represented as strings, and k is a real number (floating point number). Given some queries, return the answers. If the answer does not exist, return -1.0.\r\n\r\nExample:\r\nGiven  a / b = 2.0, b / c = 3.0.\r\nqueries are:  a / c = ?, b / a = ?, a / e = ?, a / a = ?, x / x = ? .\r\nreturn  [6.0, 0.5, -1.0, 1.0, -1.0 ].\r\n\r\nThe input is:  vector<pair<string, string>> equations, vector<double>& values, vector<pair<string, string>> queries , where equations.size() == values.size(), and the values are positive. This represents the equations. Return  vector<double>.\r\n\r\nAccording to the example above:\r\n\r\n\r\nequations = [ [\"a\", \"b\"], [\"b\", \"c\"] ],\r\nvalues = [2.0, 3.0],\r\nqueries = [ [\"a\", \"c\"], [\"b\", \"a\"], [\"a\", \"e\"], [\"a\", \"a\"], [\"x\", \"x\"] ]. \r\n\r\n \r\n\r\nThe input is always valid. You may assume that evaluating the queries will result in no division by zero and there is no contradiction.\r\n"},{"index":239,"title":"Sliding Window Maximum","body":{"mySolution":[{"time":"","space":"","code":"","language":""}],"optimizedSolution":[{"time":"$O(N)$","space":"$O(N)$ $k$ for the deque, $n - k + 1$ for the output","code":"from collections import deque\nclass Solution:\n    def maxSlidingWindow(self, nums: 'List[int]', k: 'int') -> 'List[int]':\n        # base cases\n        n = len(nums)\n        if n * k == 0:\n            return []\n        if k == 1:\n            return nums\n        \n        # For a sliding window\n        # deq keeps (index of) the maximum number\n        # and the \"potential maximum\" numbers after the maximum number \n        deq = deque()\n        # The deq is in decreasing order\n        # so the maximum elment is always deq[0]\n        for i in range(k):\n            # Everytime before we append a new number\n            # we remove the numbers that are smaller than nums[i]\n            # since they will not be the maximum\n            while deq and nums[i] > nums[deq[-1]]:\n                deq.pop()\n            deq.append(i)\n        output = [nums[deq[0]]]\n        \n        for i in range(k, n):\n            # If the maximum number is out of the window\n            # we popleft it\n            if deq and deq[0] == i - k:\n                deq.popleft()  \n            while deq and nums[i] > nums[deq[-1]]:\n                deq.pop()          \n            deq.append(i)\n            output.append(nums[deq[0]])\n\n        return output","language":"python"},{"time":"$O(N)$","space":"$O(N)$","code":"class Solution:\n    def maxSlidingWindow(self, nums: 'List[int]', k: 'int') -> 'List[int]':\n        # base cases\n        n = len(nums)\n        if n * k == 0:\n            return []\n        if k == 1:\n            return nums\n        # Split the whole list into blocks of size k\n        # The last one can be smaller than k.\n        \n        # left[i]: the maximum number from the nearest block start to i\n        # right[i]: the maximum number from the nearest block end to i\n        left = [0] * n\n        right = [0] * n\n        maxleft = maxright = float('-inf')\n        \n        for i in range(n):\n            maxleft = max(nums[i], maxleft)\n            left[i] = maxleft\n            if (i + 1) % k == 0:\n                maxleft = float('-inf')\n                \n        for i in range(n - 1, -1, -1):\n            if (i + 1) % k == 0:\n                maxright = float('-inf')\n            maxright = max(nums[i], maxright)\n            right[i] = maxright\n        \n        output = [0] * (n - k + 1)\n        for i in range(0, n - k + 1):\n            output[i] = max(right[i], left[i + k - 1])\n            \n        return output\n            ","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/sliding-window-maximum/","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [ ] can-optimize\n- [x] not-intuitive\n- [ ] bad-problem","Thinking":""},"desc":"Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.\r\n\r\nExample:\r\n\r\n\r\nInput: nums = [1,3,-1,-3,5,3,6,7], and k = 3\r\nOutput: [3,3,5,5,6,7] \r\nExplanation: \r\n\r\nWindow position                Max\r\n---------------               -----\r\n[1  3  -1] -3  5  3  6  7       3\r\n 1 [3  -1  -3] 5  3  6  7       3\r\n 1  3 [-1  -3  5] 3  6  7       5\r\n 1  3  -1 [-3  5  3] 6  7       5\r\n 1  3  -1  -3 [5  3  6] 7       6\r\n 1  3  -1  -3  5 [3  6  7]      7\r\n\r\n\r\nNote: \r\nYou may assume k is always valid, 1 ≤ k ≤ input array's size for non-empty array.\r\n\r\nFollow up:\r\nCould you solve it in linear time?"},{"index":139,"title":"Word Break","body":{"mySolution":[],"optimizedSolution":[{"time":"$O(N^2)$","space":"$O(N)$","code":"class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        word_set = set(wordDict)\n        min_len = float('inf')\n        max_len = 0\n        for w in word_set:\n            min_len = min(len(w), min_len)\n            max_len = max(len(w), max_len)\n        \n        l = len(s)\n        memo = [None] * (l + 1)\n        \n        def helper(start):\n            if start == l:\n                return True\n            if memo[start] is not None:\n                return memo[start]\n            for i in range(start, l):\n                if i - start + 1 >= min_len and i - start + 1 <= max_len and s[start:i+1] in word_set:\n                    if helper(i + 1):\n                        memo[start] = True\n                        return True\n            memo[start] = False\n            return False\n        \n        return helper(0)","language":"python"},{"time":"$O(N^2)$","space":"$O(N)$","code":"class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        word_set = set(wordDict)\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        # dp[j] represents whether s[:j] can be represented by the dict\n        # dp[0] is considered to be true\n        for i in range(len(s)):\n            for j in range(i + 1):\n                if dp[j] and s[j:i+1] in word_set:\n                    dp[i + 1] = True\n                    break\n        return dp[len(s)]","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/word-break/","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [x] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem","Thinking":"I have thought of the brute force solution but without the memoization step, which would solve the TLE issue for me."},"desc":"Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, determine if s can be segmented into a space-separated sequence of one or more dictionary words.\r\n\r\nNote:\r\n\r\n\r\n\tThe same word in the dictionary may be reused multiple times in the segmentation.\r\n\tYou may assume the dictionary does not contain duplicate words.\r\n\r\n\r\nExample 1:\r\n\r\n\r\nInput: s = \"leetcode\", wordDict = [\"leet\", \"code\"]\r\nOutput: true\r\nExplanation: Return true because \"leetcode\" can be segmented as \"leet code\".\r\n\r\n\r\nExample 2:\r\n\r\n\r\nInput: s = \"applepenapple\", wordDict = [\"apple\", \"pen\"]\r\nOutput: true\r\nExplanation: Return true because \"applepenapple\" can be segmented as \"apple pen apple\".\r\n             Note that you are allowed to reuse a dictionary word.\r\n\r\n\r\nExample 3:\r\n\r\n\r\nInput: s = \"catsandog\", wordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\r\nOutput: false\r\n\r\n"},{"index":206,"title":"Reverse Linked List","body":{"mySolution":[{"time":"$O(N)$","space":"$O(1)$","code":"class Solution(object):\n    def reverseList(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: ListNode\n        \"\"\"\n        if not head: return head\n        n, nx = head, head.next\n        n.next = None\n        while nx:\n            nxx = nx.next\n            nx.next = n\n            n, nx = nx, nxx\n        return n","language":"python"},{"time":"$O(N)$","space":"$O(N)$","code":"class Solution(object):\n    def reverseList(self, head):\n        if not head or not head.next: return head\n        p = self.reverseList(head.next)\n        head.next.next = head\n        head.next = None\n        return p","language":"python"}],"optimizedSolution":[],"anki":"","Link":"https://leetcode.com/problems/reverse-linked-list/","Solved":"- [x] solved\n- [ ] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [x] fully-master\n- [ ] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem"},"desc":"Reverse a singly linked list.\r\n\r\nExample:\r\n\r\n\r\nInput: 1->2->3->4->5->NULL\r\nOutput: 5->4->3->2->1->NULL\r\n\r\n\r\nFollow up:\r\n\r\nA linked list can be reversed either iteratively or recursively. Could you implement both?\r\n"},{"index":269,"title":"Alien Dictionary","body":{"mySolution":[],"optimizedSolution":[{"time":"$O(V+E)$ where $V$ is the vertices of the graph and $E$ is the edges","space":"$O(V+E)$","code":"from collections import defaultdict, deque\n\nclass Solution:\n    def alienOrder(self, words: List[str]) -> str:\n        indegree = {}\n        after_dict = defaultdict(list)\n        \n        for c in ''.join(words):\n            indegree[c] = 0\n\n        for i in range(len(words) - 1):\n            ind = 0\n            while ind < len(words[i]) and ind < len(words[i + 1]) and words[i][ind] == words[i + 1][ind]:\n                ind += 1\n            # Identical or prefix\n            if ind == len(words[i]) or ind == len(words[i + 1]):\n                continue\n            else:\n                pre = words[i][ind]\n                after = words[i + 1][ind]\n                indegree[after] += 1\n                after_dict[pre].append(after)\n\n        q = deque([k for k in indegree.keys() if indegree[k] == 0])\n        res = ''\n        visited = 0\n        while q:\n            k = q.popleft()\n            res += k\n            visited += 1\n            for after in after_dict[k]:\n                indegree[after] -= 1\n                if indegree[after] == 0:\n                    q.append(after)\n        \n        return '' if visited != len(indegree) else res","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/alien-dictionary/","Related":"- [207. Course Schedule](quiver-note-url/B50011DE-B57A-4A0C-8FEB-6EF3630E50E3)","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [ ] can-optimize\n- [x] not-intuitive\n- [ ] bad-problem","Test Cases":"- [\"xz\",\"zx\",\"za\",\"axf\"]: Test unordered char 'f' and rearrange of order\n- [\"z\", \"x\", \"z\", \"a\"]: Invalid order\n- [\"xz\",\"zx\",\"zx\",\"za\",\"zaf\",\"ax\"]: Prefix"},"desc":"There is a new alien language which uses the latin alphabet. However, the order among letters are unknown to you. You receive a list of non-empty words from the dictionary, where words are sorted lexicographically by the rules of this new language. Derive the order of letters in this language.\r\n\r\nExample 1:\r\n\r\n\r\nInput:\r\n[\r\n  \"wrt\",\r\n  \"wrf\",\r\n  \"er\",\r\n  \"ett\",\r\n  \"rftt\"\r\n]\r\n\r\nOutput: \"wertf\"\r\n\r\n\r\nExample 2:\r\n\r\n\r\nInput:\r\n[\r\n  \"z\",\r\n  \"x\"\r\n]\r\n\r\nOutput: \"zx\"\r\n\r\n\r\nExample 3:\r\n\r\n\r\nInput:\r\n[\r\n  \"z\",\r\n  \"x\",\r\n  \"z\"\r\n] \r\n\r\nOutput: \"\" \r\n\r\nExplanation: The order is invalid, so return \"\".\r\n\r\n\r\nNote:\r\n\r\n\r\n\tYou may assume all letters are in lowercase.\r\n\tYou may assume that if a is a prefix of b, then a must appear before b in the given dictionary.\r\n\tIf the order is invalid, return an empty string.\r\n\tThere may be multiple valid order of letters, return any one of them is fine.\r\n\r\n"},{"index":1,"title":"Two Sum","body":{"mySolution":[{"time":"$O(N^2)$","space":"$O(1)$","code":"class Solution {\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        vector<int> result(2, 0);\n        for (int i = 0; i < nums.size() - 1; ++i) {\n            for (int j = i + 1; j < nums.size(); ++j) {\n                if (nums[i] + nums[j] == target) {\n                    result[0] = i;\n                    result[1] = j;\n                }\n            }\n        }\n        return result;\n    }\n};","language":"cpp"}],"optimizedSolution":[{"time":"$O(N)$","space":"$O(N)$","code":"class Solution {\n// Using of unordered_map\n// Directly return initializer list\npublic:\n    vector<int> twoSum(vector<int>& nums, int target) {\n        unordered_map<int, int> hash;\n        for (int i = 0; i < nums.size(); ++i) {\n            if (hash.find(target - nums[i]) != hash.end()) {\n                return {hash[target - nums[i]], i};\n            }\n            hash[nums[i]] = i;\n        }\n        return {};\n    }\n};","language":"cpp"}],"anki":"Use hash to search for another number","Link":"https://leetcode.com/problems/two-sum/","Related":"","Solved":"- [x] solved\n- [ ] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [x] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem","Test Cases":""},"desc":"Given an array of integers, return indices of the two numbers such that they add up to a specific target.\r\n\r\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\r\n\r\nExample:\r\n\r\n\r\nGiven nums = [2, 7, 11, 15], target = 9,\r\n\r\nBecause nums[0] + nums[1] = 2 + 7 = 9,\r\nreturn [0, 1].\r\n\r\n"},{"index":70,"title":"Climbing Stairs","body":{"mySolution":[{"time":"$O(N)$","space":"$O(1)$","code":"class Solution:\n    def climbStairs(self, n: int) -> int:\n        if n == 1: return 1\n\n        dp = [0] * n\n        dp[0] = 1\n        dp[1] = 2\n\n        for i in range(2, n):\n            dp[i] = dp[i - 1] + dp[i - 2]\n\n        return dp[n - 1]","language":"python"}],"optimizedSolution":[],"anki":"Dynamic programming","Link":"https://leetcode.com/problems/climbing-stairs/","Solved":"- [x] solved\n- [ ] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [x] fully-master\n- [ ] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem"},"desc":"You are climbing a stair case. It takes n steps to reach to the top.\r\n\r\nEach time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?\r\n\r\nNote: Given n will be a positive integer.\r\n\r\nExample 1:\r\n\r\n\r\nInput: 2\r\nOutput: 2\r\nExplanation: There are two ways to climb to the top.\r\n1. 1 step + 1 step\r\n2. 2 steps\r\n\r\n\r\nExample 2:\r\n\r\n\r\nInput: 3\r\nOutput: 3\r\nExplanation: There are three ways to climb to the top.\r\n1. 1 step + 1 step + 1 step\r\n2. 1 step + 2 steps\r\n3. 2 steps + 1 step\r\n\r\n"},{"index":309,"title":"Best Time to Buy and Sell Stock with Cooldown","body":{"mySolution":[{"time":"","space":"","code":"","language":""}],"optimizedSolution":[{"time":"$O(N)$","space":"$O(N)$","code":"class Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        if not prices:\n            return 0\n\n        s0 = [0] * len(prices)\n        s1 = [0] * len(prices)\n        s2 = [0] * len(prices)\n        \n        s0[0] = 0\n        s1[0] = -prices[0]\n        s2[0] = float('-inf')\n        \n        for i in range(1, len(prices)):\n            s0[i] = max(s0[i - 1], s2[i - 1])\n            s1[i] = max(s0[i - 1] - prices[i], s1[i - 1])\n            s2[i] = s1[i - 1] + prices[i]\n            \n        return max(s2[len(prices) - 1], s0[len(prices) - 1])","language":"python"},{"time":"$O(N)$","space":"$O(1)$","code":"class Solution:\n    # Similar with other dp problems\n    # the space usage can be optimized\n    def maxProfit(self, prices: List[int]) -> int:\n        if not prices:\n            return 0\n        \n        s0 = 0\n        s1 = -prices[0]\n        s2 = float('-inf')\n        \n        for i in range(1, len(prices)):\n            tmp = s1\n            s1 = max(s0 - prices[i], tmp)\n            s0 = max(s0, s2)\n            s2 = tmp + prices[i]\n            \n        return max(s2, s0)","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [x] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem","Thinking":""},"desc":"Say you have an array for which the i^th element is the price of a given stock on day i.\r\n\r\nDesign an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times) with the following restrictions:\r\n\r\n\r\n\tYou may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).\r\n\tAfter you sell your stock, you cannot buy stock on next day. (ie, cooldown 1 day)\r\n\r\n\r\nExample:\r\n\r\n\r\nInput: [1,2,3,0,2]\r\nOutput: 3 \r\nExplanation: transactions = [buy, sell, cooldown, buy, sell]\r\n"},{"index":79,"title":"Word Search","body":{"mySolution":[],"optimizedSolution":[{"time":"$O(MN * S)$","space":"$O(MN)$","code":"class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        for i in range(len(board)):\n            for j in range(len(board[i])):\n                if board[i][j] == word[0] and self.dfs(board, word, i, j):\n                    return True\n        return False            \n        \n    \n    def dfs(self, board, word, i, j) -> bool:\n        if len(word) == 0:\n            return True\n        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]):\n            return False\n        if word[0] != board[i][j]:\n            return False\n        temp = board[i][j]\n        board[i][j] = '#'\n        word = word[1:]\n        res = self.dfs(board, word, i, j - 1) \\\n            or self.dfs(board, word, i - 1, j) \\\n            or self.dfs(board, word, i, j + 1) \\\n            or self.dfs(board, word, i + 1, j)\n        board[i][j] = temp\n        return res\n            ","language":"python"},{"time":"$O(MN * S)$","space":"$O(S)$","code":"class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        trace = set()\n        for i in range(len(board)):\n            for j in range(len(board[i])):\n                if board[i][j] == word[0] and self.dfs(board, word, i, j, trace):\n                    return True\n        return False            \n        \n    \n    def dfs(self, board, word, i, j, trace) -> bool:\n        if len(word) == 0:\n            return True\n        if (i, j) in trace:\n            return False\n        if i < 0 or i >= len(board) or j < 0 or j >= len(board[0]):\n            return False\n        if word[0] != board[i][j]:\n            return False\n        trace.add((i, j))\n        word = word[1:]\n        res = self.dfs(board, word, i, j - 1, trace) \\\n            or self.dfs(board, word, i - 1, j, trace) \\\n            or self.dfs(board, word, i, j + 1, trace) \\\n            or self.dfs(board, word, i + 1, j, trace)\n        trace.remove((i, j))\n        return res","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/word-search/","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [ ] can-optimize\n- [x] not-intuitive\n- [ ] bad-problem","Thinking":"It it obviously a DFS problem. Need to come up with the solution more quickly"},"desc":"Given a 2D board and a word, find if the word exists in the grid.\r\n\r\nThe word can be constructed from letters of sequentially adjacent cell, where \"adjacent\" cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.\r\n\r\nExample:\r\n\r\n\r\nboard =\r\n[\r\n  ['A','B','C','E'],\r\n  ['S','F','C','S'],\r\n  ['A','D','E','E']\r\n]\r\n\r\nGiven word = \"ABCCED\", return true.\r\nGiven word = \"SEE\", return true.\r\nGiven word = \"ABCB\", return false.\r\n\r\n"},{"index":437,"title":"Path Sum III","body":{"mySolution":[{"time":"$O(N * D)$ where $D$ is the depth of the tree, in worst case. It could add up to $O(N^2)$","space":"$O(D)$","code":"class Solution:\n    def pathSum(self, root: TreeNode, sum: int) -> int:\n        stack = []\n        res = 0\n        def dfs(node):\n            if not node:\n                return\n            stack.append(node.val)\n            s = 0\n            for i in range(len(stack) - 1, -1, -1):\n                s += stack[i]\n                nonlocal res\n                if s == sum:\n                    res += 1    \n            dfs(node.left)\n            dfs(node.right)\n            stack.pop(-1)\n        \n        dfs(root)\n        return res","language":"python"}],"optimizedSolution":[{"time":"$O(N)$ where $N$ is the number of nodes","space":"$O(N)$","code":"class Solution:\n    def pathSum(self, root: TreeNode, sum: int) -> int:\n        # Use a cache to store all the sums possible from the root to the current node\n        cache = { 0: 1 }\n        res = 0\n        def dfs(node, total):\n            if not node:\n                return            \n            total += node.val\n            # If there is a path available,\n            # there must have been an old sum in the cache\n            nonlocal res\n            res += cache.get(total - sum, 0)\n            cache[total] = cache.get(total, 0) + 1\n            dfs(node.left, total)\n            dfs(node.right, total)\n            # After finish the node,\n            # this path sum becomes unavailable in the cache\n            cache[total] -= 1\n        dfs(root, 0)\n        return res","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/path-sum-iii/","Solved":"- [x] solved\n- [ ] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [x] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem","Thinking":""},"desc":"You are given a binary tree in which each node contains an integer value.\r\n\r\nFind the number of paths that sum to a given value.\r\n\r\nThe path does not need to start or end at the root or a leaf, but it must go downwards\r\n(traveling only from parent nodes to child nodes).\r\n\r\nThe tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.\r\n\r\nExample:\r\n\r\nroot = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8\r\n\r\n      10\r\n     /  \\\r\n    5   -3\r\n   / \\    \\\r\n  3   2   11\r\n / \\   \\\r\n3  -2   1\r\n\r\nReturn 3. The paths that sum to 8 are:\r\n\r\n1.  5 -> 3\r\n2.  5 -> 2 -> 1\r\n3. -3 -> 11\r\n\r\n"},{"index":160,"title":"Intersection of Two Linked Lists","body":{"mySolution":[{"time":"$O(M+N)$","space":"$O(1)$","code":"class Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: ListNode\n        \"\"\"\n        a, b = headA, headB\n        while a and b:\n            a = a.next\n            b = b.next\n        diff = 0\n        aorb = 0 if a else 1\n        rem = a or b\n        while rem:\n            rem = rem.next\n            diff += 1\n        if aorb == 0:\n            pre, after = headA, headB\n        else:\n            pre, after = headB, headA\n        while diff > 0:\n            pre = pre.next\n            diff -= 1\n        while pre != after and pre and after:\n            pre = pre.next\n            after = after.next\n        return pre if pre and after else None","language":"python"}],"optimizedSolution":[{"time":"$O(M+N)$","space":"$O(1)$","code":"class Solution(object):\n    def getIntersectionNode(self, headA, headB):\n        \"\"\"\n        :type head1, head1: ListNode\n        :rtype: ListNode\n        \"\"\"\n        a, b = headA, headB\n        while a != b:\n            a = a.next if a else headB\n            b = b.next if b else headA\n        return a","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/intersection-of-two-linked-lists/","Solved":"- [x] solved\n- [ ] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [x] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem"},"desc":"Write a program to find the node at which the intersection of two singly linked lists begins.\r\n\r\nFor example, the following two linked lists:\r\n\r\n\r\nbegin to intersect at node c1.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\n\r\nInput: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3\r\nOutput: Reference of the node with value = 8\r\nInput Explanation: The intersected node's value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,0,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B.\r\n\r\n \r\n\r\nExample 2:\r\n\r\n\r\n\r\nInput: intersectVal = 2, listA = [0,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1\r\nOutput: Reference of the node with value = 2\r\nInput Explanation: The intersected node's value is 2 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [0,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B.\r\n\r\n\r\n \r\n\r\nExample 3:\r\n\r\n\r\n\r\nInput: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2\r\nOutput: null\r\nInput Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values.\r\nExplanation: The two lists do not intersect, so return null.\r\n\r\n\r\n \r\n\r\nNotes:\r\n\r\n\r\n\tIf the two linked lists have no intersection at all, return null.\r\n\tThe linked lists must retain their original structure after the function returns.\r\n\tYou may assume there are no cycles anywhere in the entire linked structure.\r\n\tYour code should preferably run in O(n) time and use only O(1) memory.\r\n\r\n"},{"index":8,"title":"String to Integer (atoi)","body":{"mySolution":[],"optimizedSolution":[],"anki":""},"desc":"Implement atoi which converts a string to an integer.\r\n\r\nThe function first discards as many whitespace characters as necessary until the first non-whitespace character is found. Then, starting from this character, takes an optional initial plus or minus sign followed by as many numerical digits as possible, and interprets them as a numerical value.\r\n\r\nThe string can contain additional characters after those that form the integral number, which are ignored and have no effect on the behavior of this function.\r\n\r\nIf the first sequence of non-whitespace characters in str is not a valid integral number, or if no such sequence exists because either str is empty or it contains only whitespace characters, no conversion is performed.\r\n\r\nIf no valid conversion could be performed, a zero value is returned.\r\n\r\nNote:\r\n\r\n\r\n\tOnly the space character ' ' is considered as whitespace character.\r\n\tAssume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [−2^31,  2^31 − 1]. If the numerical value is out of the range of representable values, INT_MAX (2^31 − 1) or INT_MIN (−2^31) is returned.\r\n\r\n\r\nExample 1:\r\n\r\n\r\nInput: \"42\"\r\nOutput: 42\r\n\r\n\r\nExample 2:\r\n\r\n\r\nInput: \"   -42\"\r\nOutput: -42\r\nExplanation: The first non-whitespace character is '-', which is the minus sign.\r\n             Then take as many numerical digits as possible, which gets 42.\r\n\r\n\r\nExample 3:\r\n\r\n\r\nInput: \"4193 with words\"\r\nOutput: 4193\r\nExplanation: Conversion stops at digit '3' as the next character is not a numerical digit.\r\n\r\n\r\nExample 4:\r\n\r\n\r\nInput: \"words and 987\"\r\nOutput: 0\r\nExplanation: The first non-whitespace character is 'w', which is not a numerical \r\n             digit or a +/- sign. Therefore no valid conversion could be performed.\r\n\r\nExample 5:\r\n\r\n\r\nInput: \"-91283472332\"\r\nOutput: -2147483648\r\nExplanation: The number \"-91283472332\" is out of the range of a 32-bit signed integer.\r\n             Thefore INT_MIN (−2^31) is returned.\r\n"},{"index":56,"title":"Merge Intervals","body":{"mySolution":[],"optimizedSolution":[],"anki":""},"desc":"Given a collection of intervals, merge all overlapping intervals.\r\n\r\nExample 1:\r\n\r\n\r\nInput: [[1,3],[2,6],[8,10],[15,18]]\r\nOutput: [[1,6],[8,10],[15,18]]\r\nExplanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].\r\n\r\n\r\nExample 2:\r\n\r\n\r\nInput: [[1,4],[4,5]]\r\nOutput: [[1,5]]\r\nExplanation: Intervals [1,4] and [4,5] are considered overlapping.\r\n\r\nNOTE: input types have been changed on April 15, 2019. Please reset to default code definition to get new method signature.\r\n"},{"index":141,"title":"Linked List Cycle","body":{"mySolution":[{"time":"$O(N)$","space":"$O(N)$","code":"# Definition for singly-linked list.\n# class ListNode(object):\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\nclass Solution(object):\n    def hasCycle(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        if not head: return False\n        s = set([head])\n        while head.next:\n            head = head.next\n            if head in s:\n                return True\n            s.add(head)\n        return False\n        ","language":"python"},{"time":"$O(N)$","space":"$O(1)$","code":"class Solution(object):\n   class Solution(object):\n    def hasCycle(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        while head:\n            if head.val == '#': return True\n            head.val = '#'\n            head = head.next\n        return False\n        ","language":"python"}],"optimizedSolution":[{"time":"$O(N)$","space":"$O(1)$","code":"class Solution(object):\n    def hasCycle(self, head):\n        \"\"\"\n        :type head: ListNode\n        :rtype: bool\n        \"\"\"\n        slow = fast = head\n        while fast and slow:\n            if not fast.next: return False\n            fast = fast.next.next\n            slow = slow.next\n            if fast == slow: return True\n        return False","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/linked-list-cycle/","Solved":"- [x] solved\n- [ ] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [x] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem","Thinking":"What I thought about this problem"},"desc":"Given a linked list, determine if it has a cycle in it.\r\n\r\nTo represent a cycle in the given linked list, we use an integer pos which represents the position (0-indexed) in the linked list where tail connects to. If pos is -1, then there is no cycle in the linked list.\r\n\r\n \r\n\r\n\r\nExample 1:\r\n\r\n\r\nInput: head = [3,2,0,-4], pos = 1\r\nOutput: true\r\nExplanation: There is a cycle in the linked list, where tail connects to the second node.\r\n\r\n\r\n\r\n\r\n\r\n\r\nExample 2:\r\n\r\n\r\nInput: head = [1,2], pos = 0\r\nOutput: true\r\nExplanation: There is a cycle in the linked list, where tail connects to the first node.\r\n\r\n\r\n\r\n\r\n\r\n\r\nExample 3:\r\n\r\n\r\nInput: head = [1], pos = -1\r\nOutput: false\r\nExplanation: There is no cycle in the linked list.\r\n\r\n\r\n\r\n\r\n\r\n \r\n\r\nFollow up:\r\n\r\nCan you solve it using O(1) (i.e. constant) memory?\r\n"},{"index":37,"title":"Sudoku Solver","body":{"mySolution":[],"optimizedSolution":[],"anki":""},"desc":"Write a program to solve a Sudoku puzzle by filling the empty cells.\r\n\r\nA sudoku solution must satisfy all of the following rules:\r\n\r\n\r\n\tEach of the digits 1-9 must occur exactly once in each row.\r\n\tEach of the digits 1-9 must occur exactly once in each column.\r\n\tEach of the the digits 1-9 must occur exactly once in each of the 9 3x3 sub-boxes of the grid.\r\n\r\n\r\nEmpty cells are indicated by the character '.'.\r\n\r\n\r\nA sudoku puzzle...\r\n\r\n\r\n...and its solution numbers marked in red.\r\n\r\nNote:\r\n\r\n\r\n\tThe given board contain only digits 1-9 and the character '.'.\r\n\tYou may assume that the given Sudoku puzzle will have a single unique solution.\r\n\tThe given board size is always 9x9.\r\n\r\n"},{"index":48,"title":"Rotate Image","body":{"mySolution":[{"time":"$O(N^2)$","space":"$O(1)$","code":"class Solution:\n    def rotate(self, matrix: List[List[int]]) -> None:\n        \"\"\"\n        Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        n = len(matrix)\n        for i in range(0, n // 2 + 1):\n            for j in range(i, n - i - 1):\n                matrix[j][n - 1 - i], matrix[n - 1 - i][n - 1 - j], matrix[n - 1 - j][i], matrix[i][j] = \\\n                matrix[i][j], matrix[j][n - 1 - i], matrix[n - 1 - i][n - 1 - j], matrix[n - 1 - j][i]\n                \n        ","language":"python"}],"optimizedSolution":[{"time":"$O(N^2)$","space":"$O(1)$","code":"class Solution:\n    def rotate(self, matrix):\n        \"\"\"\n        :type matrix: List[List[int]]\n        :rtype: void Do not return anything, modify matrix in-place instead.\n        \"\"\"\n        n = len(matrix[0])        \n        # transpose matrix\n        for i in range(n):\n            for j in range(i, n):\n                matrix[j][i], matrix[i][j] = matrix[i][j], matrix[j][i] \n        \n        # reverse each row\n        for i in range(n):\n            matrix[i].reverse()","language":"python"}],"anki":"1. Dealing four symmtric points at a time. Cycle between the four\n2. Transpose and reverse row","Link":"https://leetcode.com/problems/rotate-image/","Solved":"- [x] solved\n- [ ] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [x] fully-master\n- [ ] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem"},"desc":"You are given an n x n 2D matrix representing an image.\r\n\r\nRotate the image by 90 degrees (clockwise).\r\n\r\nNote:\r\n\r\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\r\n\r\nExample 1:\r\n\r\n\r\nGiven input matrix = \r\n[\r\n  [1,2,3],\r\n  [4,5,6],\r\n  [7,8,9]\r\n],\r\n\r\nrotate the input matrix in-place such that it becomes:\r\n[\r\n  [7,4,1],\r\n  [8,5,2],\r\n  [9,6,3]\r\n]\r\n\r\n\r\nExample 2:\r\n\r\n\r\nGiven input matrix =\r\n[\r\n  [ 5, 1, 9,11],\r\n  [ 2, 4, 8,10],\r\n  [13, 3, 6, 7],\r\n  [15,14,12,16]\r\n], \r\n\r\nrotate the input matrix in-place such that it becomes:\r\n[\r\n  [15,13, 2, 5],\r\n  [14, 3, 4, 1],\r\n  [12, 6, 8, 9],\r\n  [16, 7,10,11]\r\n]\r\n\r\n"},{"index":103,"title":"Binary Tree Zigzag Level Order Traversal","body":{"mySolution":[],"optimizedSolution":[{"time":"$O(N)$","space":"$O(N)$","code":"from collections import deque\n\nclass Solution:\n    def zigzagLevelOrder(self, root: TreeNode) -> List[List[int]]:\n        res = []\n        q = deque([root])\n        flag = False\n        while q:\n            # Use size to keep track of the number of nodes in one level\n            s = len(q)\n            level = []\n            for _ in range(s):\n                if flag:\n                    node = q.popleft()\n                    if not node:\n                        continue\n                    level.append(node.val)\n                    q.append(node.right)\n                    q.append(node.left)\n                else:\n                    node = q.pop()\n                    if not node:\n                        continue\n                    level.append(node.val)\n                    q.appendleft(node.left)\n                    q.appendleft(node.right)\n            if len(level) > 0:\n                res.append(level)\n            flag = not flag\n        return res","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [ ] can-optimize\n- [x] not-intuitive\n- [ ] bad-problem","Thinking":""},"desc":"Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).\r\n\r\n\r\nFor example:\r\nGiven binary tree [3,9,20,null,null,15,7],\r\n\r\n    3\r\n   / \\\r\n  9  20\r\n    /  \\\r\n   15   7\r\n\r\n\r\n\r\nreturn its zigzag level order traversal as:\r\n\r\n[\r\n  [3],\r\n  [20,9],\r\n  [15,7]\r\n]\r\n\r\n"},{"index":621,"title":"Task Scheduler","body":{"mySolution":[{"time":"$O(N)$","space":"$O(1)$","code":"class Solution:\n    def leastInterval(self, tasks, N):\n        task_counts = collections.Counter(tasks).values()\n        # Get the max counts of all the tasks \n        M = max(task_counts)\n        # The number of tasks of max counts\n        Mct = list(task_counts).count(M)\n        return max(len(tasks), (M - 1) * (N + 1) + Mct)","language":"python"}],"optimizedSolution":[],"anki":"","Link":"https://leetcode.com/problems/task-scheduler/","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [ ] can-optimize\n- [x] not-intuitive\n- [ ] bad-problem","Thinking":""},"desc":"Given a char array representing tasks CPU need to do. It contains capital letters A to Z where different letters represent different tasks. Tasks could be done without original order. Each task could be done in one interval. For each interval, CPU could finish one task or just be idle.\r\n\r\nHowever, there is a non-negative cooling interval n that means between two same tasks, there must be at least n intervals that CPU are doing different tasks or just be idle.\r\n\r\nYou need to return the least number of intervals the CPU will take to finish all the given tasks.\r\n\r\n \r\n\r\nExample:\r\n\r\n\r\nInput: tasks = [\"A\",\"A\",\"A\",\"B\",\"B\",\"B\"], n = 2\r\nOutput: 8\r\nExplanation: A -> B -> idle -> A -> B -> idle -> A -> B.\r\n\r\n\r\n \r\n\r\nNote:\r\n\r\n\r\n\tThe number of tasks is in the range [1, 10000].\r\n\tThe integer n is in the range [0, 100].\r\n\r\n"},{"index":39,"title":"Combination Sum","body":{"mySolution":[],"optimizedSolution":[],"anki":""},"desc":"Given a set of candidate numbers (candidates) (without duplicates) and a target number (target), find all unique combinations in candidates where the candidate numbers sums to target.\r\n\r\nThe same repeated number may be chosen from candidates unlimited number of times.\r\n\r\nNote:\r\n\r\n\r\n\tAll numbers (including target) will be positive integers.\r\n\tThe solution set must not contain duplicate combinations.\r\n\r\n\r\nExample 1:\r\n\r\n\r\nInput: candidates = [2,3,6,7], target = 7,\r\nA solution set is:\r\n[\r\n  [7],\r\n  [2,2,3]\r\n]\r\n\r\n\r\nExample 2:\r\n\r\n\r\nInput: candidates = [2,3,5], target = 8,\r\nA solution set is:\r\n[\r\n  [2,2,2,2],\r\n  [2,3,3],\r\n  [3,5]\r\n]\r\n\r\n"},{"index":73,"title":"Set Matrix Zeroes","body":{"mySolution":[],"optimizedSolution":[],"anki":""},"desc":"Given a m x n matrix, if an element is 0, set its entire row and column to 0. Do it in-place.\r\n\r\nExample 1:\r\n\r\n\r\nInput: \r\n[\r\n  [1,1,1],\r\n  [1,0,1],\r\n  [1,1,1]\r\n]\r\nOutput: \r\n[\r\n  [1,0,1],\r\n  [0,0,0],\r\n  [1,0,1]\r\n]\r\n\r\n\r\nExample 2:\r\n\r\n\r\nInput: \r\n[\r\n  [0,1,2,0],\r\n  [3,4,5,2],\r\n  [1,3,1,5]\r\n]\r\nOutput: \r\n[\r\n  [0,0,0,0],\r\n  [0,4,5,0],\r\n  [0,3,1,0]\r\n]\r\n\r\n\r\nFollow up:\r\n\r\n\r\n\tA straight forward solution using O(mn) space is probably a bad idea.\r\n\tA simple improvement uses O(m + n) space, but still not the best solution.\r\n\tCould you devise a constant space solution?\r\n\r\n"},{"index":771,"title":"Jewels and Stones","body":{"mySolution":[{"time":"$O(S+J)$","space":"$O(1)$ since there are only (a-z + A-Z) characters will be present in the set","code":"class Solution:\n    def numJewelsInStones(self, J: str, S: str) -> int:\n        return sum(c in set(J) for c in S)","language":"python"}],"optimizedSolution":[],"anki":"","Link":"https://leetcode.com/problems/jewels-and-stones/","Solved":"- [x] solved\n- [ ] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [x] fully-master\n- [ ] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem","Thinking":""},"desc":"You're given strings J representing the types of stones that are jewels, and S representing the stones you have.  Each character in S is a type of stone you have.  You want to know how many of the stones you have are also jewels.\r\n\r\nThe letters in J are guaranteed distinct, and all characters in J and S are letters. Letters are case sensitive, so \"a\" is considered a different type of stone from \"A\".\r\n\r\nExample 1:\r\n\r\n\r\nInput: J = \"aA\", S = \"aAAbbbb\"\r\nOutput: 3\r\n\r\n\r\nExample 2:\r\n\r\n\r\nInput: J = \"z\", S = \"ZZ\"\r\nOutput: 0\r\n\r\n\r\nNote:\r\n\r\n\r\n\tS and J will consist of letters and have length at most 50.\r\n\tThe characters in J are distinct.\r\n\r\n"},{"index":152,"title":"Maximum Product Subarray","body":{"mySolution":[],"optimizedSolution":[{"time":"$O(N)$","space":"$O(1)$","code":"class Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        if not nums: return 0\n        imin = imax = nums[0]\n        r = imax\n        for i in range(1, len(nums)):\n            if nums[i] < 0:\n                imin, imax = imax, imin\n            imax = max(nums[i], nums[i] * imax)\n            imin = min(nums[i], nums[i] * imin)\n            r = max(r, imax)\n        return r","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/maximum-product-subarray/","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [ ] can-optimize\n- [x] not-intuitive\n- [ ] bad-problem"},"desc":"Given an integer array nums, find the contiguous subarray within an array (containing at least one number) which has the largest product.\r\n\r\nExample 1:\r\n\r\n\r\nInput: [2,3,-2,4]\r\nOutput: 6\r\nExplanation: [2,3] has the largest product 6.\r\n\r\n\r\nExample 2:\r\n\r\n\r\nInput: [-2,0,-1]\r\nOutput: 0\r\nExplanation: The result cannot be 2, because [-2,-1] is not a subarray.\r\n"},{"index":2,"title":"Add Two Numbers","body":{"mySolution":[{"time":"$O(N)$","space":"$O(N)$","code":"class Solution {\npublic:\n    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {\n        int carrier = 0;\n        ListNode* dummy = new ListNode(0);\n        ListNode* node = dummy;\n        while (l1 || l2 || carrier != 0) {\n            if (l1) {\n                carrier += l1->val;\n                l1 = l1->next;\n            }\n            if (l2) {\n                carrier += l2->val;\n                l2 = l2->next;\n            }\n            node->next = new ListNode(carrier % 10);\n            carrier = carrier / 10;\n            node = node->next;\n        }\n        return dummy->next;\n    }\n};","language":"cpp"}],"optimizedSolution":[],"anki":"Use a `carrier` and dummy head","Link":"https://leetcode.com/problems/add-two-numbers/","Related":"","Solved":"- [x] solved\n- [ ] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [x] fully-master\n- [ ] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem","Test Cases":""},"desc":"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.\r\n\r\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\r\n\r\nExample:\r\n\r\n\r\nInput: (2 -> 4 -> 3) + (5 -> 6 -> 4)\r\nOutput: 7 -> 0 -> 8\r\nExplanation: 342 + 465 = 807.\r\n\r\n"},{"index":240,"title":"Search a 2D Matrix II","body":{"mySolution":[{"time":"","space":"","code":"","language":""}],"optimizedSolution":[{"time":"$O(M+N)$","space":"$O(1)$","code":"class Solution:\n    def searchMatrix(self, matrix, target):\n        if not matrix:\n            return False\n        \n        n = len(matrix)\n        m = len(matrix[0])\n        \n        if n * m == 0:\n            return False\n        \n        # We starting from the bottom-left corner\n        i, j = n - 1, 0\n        \n        while i < n and i > -1 and j < m and j > -1:\n            ele = matrix[i][j]\n            if ele == target:\n                return True\n            # If the current element > target\n            # we prune the other elements in the ith row on the left\n            elif ele > target:\n                i -= 1\n            # Similarly, if the current element < target\n            # we prune the other eleents in the jth row on the top\n            else:\n                j += 1\n        \n        # If the pointer is out of the matrix, it means we cannot find the element\n        return False","language":"python"},{"time":"$O(nlog(n))$. This could be deducted from the [master theorem](https://en.wikipedia.org/wiki/Master_theorem_(analysis_of_algorithms))","space":"$O(log(n))$ since we discard half of the matrix each time","code":"class Solution:\n    def searchMatrix(self, matrix, target):\n        if not matrix:\n            return False\n        \n        def search_rec(x, y, end_x, end_y):\n            if x > end_x or y > end_y:\n                return False\n            elif target > matrix[end_x][end_y] or target < matrix[x][y]:\n                return False\n            start =  x\n            mid_col = (y + end_y) // 2\n            \n            # First in the middle column of the matrix, we look for a start index such that\n            # matrix[start - 1][mid_col] < target and matrix[start][mid_col] > target\n            # If we find the target in this process, we return True\n            \n            while start <= end_x and matrix[start][mid_col] <= target:\n                if matrix[start][mid_col] == target:\n                    return True\n                start += 1\n            \n            # The matrix is then divided into four parts by the mid_col and start_index\n            # We look for the target in the bottom-left and top-right matrix. \n            return search_rec(x, mid_col + 1, start - 1, end_y) or search_rec(start, y, end_x, mid_col - 1)\n        \n        return search_rec(0, 0, len(matrix) - 1, len(matrix[0]) - 1)","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/search-a-2d-matrix-ii/","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [ ] can-optimize\n- [x] not-intuitive\n- [ ] bad-problem","Thinking":""},"desc":"Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\r\n\r\n\r\n\tIntegers in each row are sorted in ascending from left to right.\r\n\tIntegers in each column are sorted in ascending from top to bottom.\r\n\r\n\r\nExample:\r\n\r\nConsider the following matrix:\r\n\r\n\r\n[\r\n  [1,   4,  7, 11, 15],\r\n  [2,   5,  8, 12, 19],\r\n  [3,   6,  9, 16, 22],\r\n  [10, 13, 14, 17, 24],\r\n  [18, 21, 23, 26, 30]\r\n]\r\n\r\n\r\nGiven target = 5, return true.\r\n\r\nGiven target = 20, return false.\r\n"},{"index":78,"title":"Subsets","body":{"mySolution":[{"time":"$O(2^N)$","space":"$O(2^N)$","code":"class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        if len(nums) == 0:\n            return [[]]\n        return self.subsets(nums[1:]) + [([nums[0]] + s) for s in self.subsets(nums[1:])]\n```\n\n**Optimized Solution (I, II, III...)**Jk:\n*Time*: $O(N)$ \n*Space*: $O(N^2)$\n```\nPost the optimized solution after looking at the solution. ","language":""}],"optimizedSolution":[],"anki":"","Link":"https://leetcode.com/problems/subsets/","Solved":"- [x] solved\n- [ ] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [x] fully-master\n- [ ] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem","Thinking":"What I thought about this problem"},"desc":"Given a set of distinct integers, nums, return all possible subsets (the power set).\r\n\r\nNote: The solution set must not contain duplicate subsets.\r\n\r\nExample:\r\n\r\n\r\nInput: nums = [1,2,3]\r\nOutput:\r\n[\r\n  [3],\r\n  [1],\r\n  [2],\r\n  [1,2,3],\r\n  [1,3],\r\n  [2,3],\r\n  [1,2],\r\n  []\r\n]\r\n"},{"index":208,"title":"Implement Trie (Prefix Tree)","body":{"mySolution":[{"time":"$O(N)$ where $N$ is the size of the word","space":"depends on the opearation","code":"class TrieNode:\n    def __init__(self):\n        self.isEnd = False\n        self.next = dict()\n\nclass Trie:\n\n    def __init__(self):\n        \"\"\"\n        Initialize your data structure here.\n        \"\"\"\n        self.root = TrieNode()\n        \n\n    def insert(self, word: str) -> None:\n        \"\"\"\n        Inserts a word into the trie.\n        \"\"\"\n        node = self.root\n        for c in word:\n            if c not in node.next:\n                node.next[c] = TrieNode()\n            node = node.next[c]\n        node.isEnd = True\n        \n    def _search_node(self, word: str):\n        node = self.root\n        for c in word:\n            if c not in node.next:\n                return None\n            node = node.next[c]\n        return node\n                \n\n    def search(self, word: str) -> bool:\n        \"\"\"\n        Returns if the word is in the trie.\n        \"\"\"\n        last_node = self._search_node(word)\n        return last_node is not None and last_node.isEnd\n        \n\n    def startsWith(self, prefix: str) -> bool:\n        \"\"\"\n        Returns if there is any word in the trie that starts with the given prefix.\n        \"\"\"\n        return self._search_node(prefix) is not None\n        \n\n\n# Your Trie object will be instantiated and called as such:\n# obj = Trie()\n# obj.insert(word)\n# param_2 = obj.search(word)\n# param_3 = obj.startsWith(prefix) ","language":"python"}],"optimizedSolution":[{"time":"$O(N)$","space":"$O(N^2)$","code":"Post the optimized solution after looking at the solution. ","language":""}],"anki":"","Link":"https://leetcode.com/problems/implement-trie-prefix-tree/","Solved":"- [x] solved\n- [ ] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [x] fully-master\n- [ ] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem"},"desc":"Implement a trie with insert, search, and startsWith methods.\r\n\r\nExample:\r\n\r\n\r\nTrie trie = new Trie();\r\n\r\ntrie.insert(\"apple\");\r\ntrie.search(\"apple\");   // returns true\r\ntrie.search(\"app\");     // returns false\r\ntrie.startsWith(\"app\"); // returns true\r\ntrie.insert(\"app\");   \r\ntrie.search(\"app\");     // returns true\r\n\r\n\r\nNote:\r\n\r\n\r\n\tYou may assume that all inputs are consist of lowercase letters a-z.\r\n\tAll inputs are guaranteed to be non-empty strings.\r\n\r\n"},{"index":126,"title":"Word Ladder II","body":{"mySolution":[],"optimizedSolution":[{"time":"$O(klN)$ where k = 26, l is the length of the words and N is the number of words","space":"$O(N)$","code":"# Original solution from https://leetcode.com/problems/word-ladder-ii/discuss/40477/Super-fast-Java-solution-(two-end-BFS)\nfrom collections import defaultdict\nfrom string import ascii_lowercase\n\nclass Solution:\n    def findLadders(self, beginWord: str, endWord: str, wordList: List[str]) -> List[List[str]]:\n        next_step = defaultdict(list)\n        all_words = set(wordList)\n        if endWord not in all_words:\n            return []\n        source = set([beginWord])\n        target = set([endWord])\n        self.helper(source, target, all_words, next_step, False)\n        result = []\n        self.gen_list(result, [], beginWord, endWord, next_step)\n        return result\n    \n    def helper(self, source, target, all_words, next_step, flip):\n        next_target = set()\n        done = False\n        if len(source) == 0 or len(target) == 0:\n            return\n        \n        if len(target) > len(source):\n            target, source = source, target\n            flip = not flip\n        \n        # Remove from all_words to avoid repetition\n        for word in source:\n            if word in all_words:\n                all_words.remove(word)\n        \n        for word in source:\n            for i in range(len(word)):\n                for c in ascii_lowercase:\n                    # Fastest way to replace one letter in word\n                    transformed = word[:i] + c + word[i+1:]\n                    key, value = word, transformed\n                    if flip:\n                        key, value = transformed, word\n                    \n                    if transformed in target:\n                        done = True\n                        next_step[key].append(value)\n                    \n                    if not done and transformed in all_words:\n                        next_target.add(transformed)\n                        next_step[key].append(value)\n        \n        return done or self.helper(target, next_target, all_words, next_step, not flip)\n    \n    def gen_list(self, res, seq, begin, end, next_step):\n        seq.append(begin)\n        if begin == end:\n            res.append(seq[:])\n        for next_word in next_step[begin]:\n            self.gen_list(res, seq, next_word, end, next_step)\n        seq.pop()","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/word-ladder-ii/","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [ ] can-optimize\n- [x] not-intuitive\n- [ ] bad-problem"},"desc":"Given two words (beginWord and endWord), and a dictionary's word list, find all shortest transformation sequence(s) from beginWord to endWord, such that:\r\n\r\n\r\n\tOnly one letter can be changed at a time\r\n\tEach transformed word must exist in the word list. Note that beginWord is not a transformed word.\r\n\r\n\r\nNote:\r\n\r\n\r\n\tReturn an empty list if there is no such transformation sequence.\r\n\tAll words have the same length.\r\n\tAll words contain only lowercase alphabetic characters.\r\n\tYou may assume no duplicates in the word list.\r\n\tYou may assume beginWord and endWord are non-empty and are not the same.\r\n\r\n\r\nExample 1:\r\n\r\n\r\nInput:\r\nbeginWord = \"hit\",\r\nendWord = \"cog\",\r\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]\r\n\r\nOutput:\r\n[\r\n  [\"hit\",\"hot\",\"dot\",\"dog\",\"cog\"],\r\n  [\"hit\",\"hot\",\"lot\",\"log\",\"cog\"]\r\n]\r\n\r\n\r\nExample 2:\r\n\r\n\r\nInput:\r\nbeginWord = \"hit\"\r\nendWord = \"cog\"\r\nwordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]\r\n\r\nOutput: []\r\n\r\nExplanation: The endWord \"cog\" is not in wordList, therefore no possible transformation.\r\n\r\n\r\n\r\n\r\n"},{"index":null,"title":"LeetCode Template","body":{"mySolution":[{"time":"$O(N)$","space":"$O(N^2)$","code":"Post my solution here, if solved successfully.","language":""}],"optimizedSolution":[{"time":"$O(N)$","space":"$O(N^2)$","code":"Post the optimized solution after looking at the solution. ","language":""}],"anki":"","Link":"","Related":"","Solved":"- [ ] solved\n- [ ] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [ ] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem","Test Cases":""},"desc":""},{"index":31,"title":"Next Permutation","body":{"mySolution":[],"optimizedSolution":[],"anki":""},"desc":"Implement next permutation, which rearranges numbers into the lexicographically next greater permutation of numbers.\r\n\r\nIf such arrangement is not possible, it must rearrange it as the lowest possible order (ie, sorted in ascending order).\r\n\r\nThe replacement must be in-place and use only constant extra memory.\r\n\r\nHere are some examples. Inputs are in the left-hand column and its corresponding outputs are in the right-hand column.\r\n\r\n1,2,3 → 1,3,2\r\n3,2,1 → 1,2,3\r\n1,1,5 → 1,5,1\r\n"},{"index":543,"title":"Diameter of Binary Tree","body":{"mySolution":[{"time":"$O(N)$ where $N$ is the number of nodes","space":"$O(N)$","code":"class Solution:\n    def diameterOfBinaryTree(self, root: TreeNode) -> int:\n        m = 0\n        def dfs(node):\n            if not node:\n                return -1\n            \n            l = dfs(node.left) + 1\n            r = dfs(node.right) + 1\n            nonlocal m\n            m = max(m, l + r)\n            return max(l, r)\n            \n        dfs(root)\n        return m","language":"python"}],"optimizedSolution":[],"anki":"","Link":"https://leetcode.com/problems/diameter-of-binary-tree/","Solved":"- [x] solved\n- [ ] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [x] fully-master\n- [ ] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem","Thinking":""},"desc":"\r\nGiven a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.\r\n\r\n\r\n\r\nExample:\r\nGiven a binary tree \r\n\r\n          1\r\n         / \\\r\n        2   3\r\n       / \\     \r\n      4   5    \r\n\r\n\r\n\r\nReturn 3, which is the length of the path [4,2,1,3] or [5,2,1,3].\r\n\r\n\r\nNote:\r\nThe length of path between two nodes is represented by the number of edges between them.\r\n"},{"index":74,"title":"Search a 2D Matrix","body":{"mySolution":[],"optimizedSolution":[],"anki":""},"desc":"Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:\r\n\r\n\r\n\tIntegers in each row are sorted from left to right.\r\n\tThe first integer of each row is greater than the last integer of the previous row.\r\n\r\n\r\nExample 1:\r\n\r\n\r\nInput:\r\nmatrix = [\r\n  [1,   3,  5,  7],\r\n  [10, 11, 16, 20],\r\n  [23, 30, 34, 50]\r\n]\r\ntarget = 3\r\nOutput: true\r\n\r\n\r\nExample 2:\r\n\r\n\r\nInput:\r\nmatrix = [\r\n  [1,   3,  5,  7],\r\n  [10, 11, 16, 20],\r\n  [23, 30, 34, 50]\r\n]\r\ntarget = 13\r\nOutput: false\r\n"},{"index":5,"title":"Longest Palindromic Substring","body":{"mySolution":[],"optimizedSolution":[{"time":"$O(N^2)$","space":"$O(1)$","code":"class Solution {\npublic:\n    string longestPalindrome(string s) {\n        if (s.length() == 0) {\n            return \"\";\n        }\n        int start = 0, end = 0;\n        for (int i = 0; i < s.length() - 1; i++) {\n            int len = max(expand(s, i, i), expand(s, i, i + 1));\n            if (len > end - start + 1) {\n                start = i - (len - 1) / 2;\n                end = i + len / 2;\n            }\n        }\n        return s.substr(start, end - start + 1);\n    }\n    \n    int expand(string s, int left, int right) {\n        while (left >= 0 && right <= s.length() - 1 && s[left] == s[right]) {\n            left--;\n            right++;\n        }\n        return right - left - 1;\n    }\n};","language":"cpp"}],"anki":"Expand from center.","Link":"https://leetcode.com/problems/longest-palindromic-substring/","Related":"","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [x] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem","Test Cases":""},"desc":"Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.\r\n\r\nExample 1:\r\n\r\n\r\nInput: \"babad\"\r\nOutput: \"bab\"\r\nNote: \"aba\" is also a valid answer.\r\n\r\n\r\nExample 2:\r\n\r\n\r\nInput: \"cbbd\"\r\nOutput: \"bb\"\r\n\r\n"},{"index":200,"title":"Number of Islands","body":{"mySolution":[],"optimizedSolution":[{"time":"$O(MN)$","space":"$O(MN)$","code":"class Solution(object):\n    def numIslands(self, grid):\n        \"\"\"\n        :type grid: List[List[str]]\n        :rtype: int\n        \"\"\"\n        cnt = 0\n        if not grid: return cnt\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == '1':\n                    cnt += 1\n                    self.dfs(grid, i, j)\n        return cnt\n    \n    def dfs(self, grid, i, j):\n        if i < 0 or i >= len(grid) or j < 0 or j >= len(grid[0]):\n            return\n        if grid[i][j] == '0':\n            return\n        grid[i][j] = '0'\n        self.dfs(grid, i - 1, j)\n        self.dfs(grid, i, j - 1)\n        self.dfs(grid, i + 1, j)\n        self.dfs(grid, i, j + 1)","language":"python"},{"time":"$O(MN)$","space":"$O(M + N)$","code":"from collections import deque\n\nclass Solution(object):\n    def numIslands(self, grid):\n        \"\"\"\n        :type grid: List[List[str]]\n        :rtype: int\n        \"\"\"\n        cnt = 0\n        q = deque([])\n        if not grid: return cnt\n        for i in range(len(grid)):\n            for j in range(len(grid[0])):\n                if grid[i][j] == '0':\n                    continue\n                  \n                cnt += 1\n                q.append((i, j))\n                while q:\n                    x, y = q.popleft()\n                    if grid[x][y] == '0':\n                        continue\n                    grid[x][y] = '0'\n                    if x > 0 and grid[x - 1][y] == '1':\n                        q.append((x - 1, y))\n                    if y > 0 and grid[x][y - 1] == '1':\n                        q.append((x, y - 1))\n                    if x < len(grid) - 1 and grid[x + 1][y] == '1':\n                        q.append((x + 1, y))\n                    if y < len(grid[0]) - 1 and grid[x][y + 1] == '1':\n                        q.append((x, y + 1))  \n        return cnt","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/number-of-islands/","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [x] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem"},"desc":"Given a 2d grid map of '1's (land) and '0's (water), count the number of islands. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\r\n\r\nExample 1:\r\n\r\n\r\nInput:\r\n11110\r\n11010\r\n11000\r\n00000\r\n\r\nOutput: 1\r\n\r\n\r\nExample 2:\r\n\r\n\r\nInput:\r\n11000\r\n11000\r\n00100\r\n00011\r\n\r\nOutput: 3\r\n"},{"index":273,"title":"Integer to English Words","body":{"mySolution":[{"time":"$O(L)$","space":"$O(1)$","code":"class Solution:\n    def __init__(self):\n        self.digit_map = {\n            0: ['', 'Ten'],\n            1: ['One', 'Eleven'],\n            2: ['Two', 'Twelve', 'Twenty'],\n            3: ['Three', 'Thirteen', 'Thirty'],\n            4: ['Four', 'Fourteen', 'Forty'],\n            5: ['Five', 'Fifteen', 'Fifty'],\n            6: ['Six', 'Sixteen', 'Sixty'],\n            7: ['Seven', 'Seventeen', 'Seventy'],\n            8: ['Eight', 'Eighteen', 'Eighty'],\n            9: ['Nine', 'Nineteen', 'Ninety'],\n        }\n        self.depth_map = {\n            1: 'Thousand',\n            2: 'Million',\n            3: 'Billion'\n        }\n    \n    def numberToWords(self, num: int) -> str:\n        if num == 0:\n            return 'Zero'\n        return self.helper(num, 0)\n\n    def helper(self, num: int, depth) -> str:\n        if num >= 1000:\n            first = self.helper(num // 1000, depth + 1)\n            second = self.helper(num % 1000, depth)\n            return first + ('' if first == '' or second == '' else ' ') + second\n\n        hundred = num // 100\n        ten = (num - 100 * hundred) // 10\n        digit = num % 10\n        res = []\n        if hundred > 0:\n            res.append(self.digit_map[hundred][0])\n            res.append('Hundred')\n        if ten > 0:\n            if ten == 1:\n                res.append(self.digit_map[digit][1])\n            else:\n                res.append(self.digit_map[ten][2])\n        if ten != 1 and digit > 0:\n            res.append(self.digit_map[digit][0])\n        \n        if depth > 0 and len(res) > 0:\n            res.append(self.depth_map[depth])\n        \n        return ' '.join(res)\n","language":"python"}],"optimizedSolution":[],"anki":"","Link":"https://leetcode.com/problems/integer-to-english-words/","Related":"","Solved":"- [x] solved\n- [ ] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [x] fully-master\n- [ ] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem","Test Cases":"* 0\n* 1000\n* 1000000\n* 1000000001"},"desc":"Convert a non-negative integer to its english words representation. Given input is guaranteed to be less than 2^31 - 1.\r\n\r\nExample 1:\r\n\r\n\r\nInput: 123\r\nOutput: \"One Hundred Twenty Three\"\r\n\r\n\r\nExample 2:\r\n\r\n\r\nInput: 12345\r\nOutput: \"Twelve Thousand Three Hundred Forty Five\"\r\n\r\nExample 3:\r\n\r\n\r\nInput: 1234567\r\nOutput: \"One Million Two Hundred Thirty Four Thousand Five Hundred Sixty Seven\"\r\n\r\n\r\nExample 4:\r\n\r\n\r\nInput: 1234567891\r\nOutput: \"One Billion Two Hundred Thirty Four Million Five Hundred Sixty Seven Thousand Eight Hundred Ninety One\"\r\n\r\n"},{"index":44,"title":"Wildcard Matching","body":{"mySolution":[],"optimizedSolution":[],"anki":""},"desc":"Given an input string (s) and a pattern (p), implement wildcard pattern matching with support for '?' and '*'.\r\n\r\n\r\n'?' Matches any single character.\r\n'*' Matches any sequence of characters (including the empty sequence).\r\n\r\n\r\nThe matching should cover the entire input string (not partial).\r\n\r\nNote:\r\n\r\n\r\n\ts could be empty and contains only lowercase letters a-z.\r\n\tp could be empty and contains only lowercase letters a-z, and characters like ? or *.\r\n\r\n\r\nExample 1:\r\n\r\n\r\nInput:\r\ns = \"aa\"\r\np = \"a\"\r\nOutput: false\r\nExplanation: \"a\" does not match the entire string \"aa\".\r\n\r\n\r\nExample 2:\r\n\r\n\r\nInput:\r\ns = \"aa\"\r\np = \"*\"\r\nOutput: true\r\nExplanation: '*' matches any sequence.\r\n\r\n\r\nExample 3:\r\n\r\n\r\nInput:\r\ns = \"cb\"\r\np = \"?a\"\r\nOutput: false\r\nExplanation: '?' matches 'c', but the second letter is 'a', which does not match 'b'.\r\n\r\n\r\nExample 4:\r\n\r\n\r\nInput:\r\ns = \"adceb\"\r\np = \"*a*b\"\r\nOutput: true\r\nExplanation: The first '*' matches the empty sequence, while the second '*' matches the substring \"dce\".\r\n\r\n\r\nExample 5:\r\n\r\n\r\nInput:\r\ns = \"acdcb\"\r\np = \"a*c?b\"\r\nOutput: false\r\n\r\n"},{"index":46,"title":"Permutations","body":{"mySolution":[],"optimizedSolution":[{"time":"$O(N!)$","space":"$O(1)$","code":"class Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        res = []\n        def perm(begin):\n            if begin == len(nums) - 1:\n                res.append(nums[:])\n                return\n            for i in range(begin, len(nums)):\n                nums[i], nums[begin] = nums[begin], nums[i]\n                perm(begin + 1)\n                nums[i], nums[begin] = nums[begin], nums[i]\n        perm(0)\n        return res","language":"python"}],"anki":"Recursive solution. For a list `nums`, and a permutation functin `permute()`, the whole set of permutation can be considered as:\n- $[nums[0], permute(nums[1:])]$\n- $[nums[1], permute(nums[0] + nums[2:])]$\n- $[nums[2], permute(nums[0, 1] + nums[3:])]$\n\nSo we swap the $i$th number of the list with the `begin`, and then permute the rest. If `begin` is equal to `len(nums) - 1`, we'll create a copy of the list and push it into the result.\n\nSince a list of length $N$ has $N!$ permutations, the time complexity must be $O(N!)$. Clearly the space complexity is $O(1)$.","Link":"https://leetcode.com/problems/permutations/","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [ ] can-optimize\n- [x] not-intuitive\n- [ ] bad-problem"},"desc":"Given a collection of distinct integers, return all possible permutations.\r\n\r\nExample:\r\n\r\n\r\nInput: [1,2,3]\r\nOutput:\r\n[\r\n  [1,2,3],\r\n  [1,3,2],\r\n  [2,1,3],\r\n  [2,3,1],\r\n  [3,1,2],\r\n  [3,2,1]\r\n]\r\n\r\n"},{"index":207,"title":"Course Schedule","body":{"mySolution":[],"optimizedSolution":[{"time":"$O(V+E)$ where $V$ is the number of vertices and $E$ is the number of edges","space":"$O(V+E)$","code":"from collections import deque\n\nclass Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        graph = [[] for _ in range(numCourses)]\n        indegree  = [0] * numCourses\n        for x, y in prerequisites:\n            graph[x].append(y)\n            indegree[y] += 1\n        \n        q = deque([x for x in range(numCourses) if indegree[x] == 0])\n        visited = 0\n        while q:\n            v = q.popleft()\n            visited += 1\n            for after in graph[v]:\n                indegree[after] -= 1\n                if indegree[after] == 0:\n                    q.append(after)\n        \n        return visited == numCourses ","language":"python"},{"time":"$O(V+E)$ where $V$ is the number of vertices and $E$ is the number of edges","space":"$O(V+E)$","code":"class Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        graph = [[] for _ in range(numCourses)]\n        visit = [0] * numCourses\n        for x, y in prerequisites:\n            graph[x].append(y)\n        def dfs(i):\n            if visit[i] == 1: return True\n            if visit[i] == -1: return False\n            visit[i] = -1\n            for e in graph[i]:\n                if not dfs(e):\n                    return False\n            visit[i] = 1\n            return True\n        for c in range(numCourses):\n            if not dfs(c):\n                return False\n        return True","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/course-schedule/","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [x] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem"},"desc":"There are a total of n courses you have to take, labeled from 0 to n-1.\r\n\r\nSome courses may have prerequisites, for example to take course 0 you have to first take course 1, which is expressed as a pair: [0,1]\r\n\r\nGiven the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?\r\n\r\nExample 1:\r\n\r\n\r\nInput: 2, [[1,0]] \r\nOutput: true\r\nExplanation: There are a total of 2 courses to take. \r\n             To take course 1 you should have finished course 0. So it is possible.\r\n\r\nExample 2:\r\n\r\n\r\nInput: 2, [[1,0],[0,1]]\r\nOutput: false\r\nExplanation: There are a total of 2 courses to take. \r\n             To take course 1 you should have finished course 0, and to take course 0 you should\r\n             also have finished course 1. So it is impossible.\r\n\r\n\r\nNote:\r\n\r\n\r\n\tThe input prerequisites is a graph represented by a list of edges, not adjacency matrices. Read more about how a graph is represented.\r\n\tYou may assume that there are no duplicate edges in the input prerequisites.\r\n\r\n"},{"index":76,"title":"Minimum Window Substring","body":{"mySolution":[{"time":"$O(S + T)$ where $S$ and $T$ are the lengths of the two strings","space":"$O(T)$","code":"class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        record = dict()\n        cur = dict()\n        for c in t:\n            record[c] = record[c] + 1 if c in record else 1\n            cur[c] = 0\n\n        right= left = 0\n        ans = (len(s) + 1, 0, 0)\n        matched = 0\n        char_num = len(record)\n\n        while right < len(s):\n            c = s[right]\n            if c in cur:\n                cur[c] += 1\n                matched += cur[c] == record[c]\n            while matched == char_num:\n                c = s[left]\n                if c in cur:\n                    cur[c] -= 1\n                    matched -= cur[c] < record[c]\n                if matched < char_num:\n                    if right - left + 1 < ans[0]:\n                        ans = (right - left + 1, left, right)\n                left += 1\n            right += 1\n            \n        return s[ans[1]:ans[2] + 1] if ans[0] <= len(s) else ''","language":"python"}],"optimizedSolution":[{"time":"$O(FILTER + T)$","space":"$O(T)$","code":"class Solution:\n    def minWindow(self, s: str, t: str) -> str:\n        record = dict()\n        cur = dict()\n        for c in t:\n            record[c] = record[c] + 1 if c in record else 1\n            cur[c] = 0\n        \n        # f for filtered\n        f = [(i, c) for i, c in enumerate(s) if c in t]\n\n        right= left = 0\n        ans = (len(s) + 1, 0, 0)\n        matched = 0\n        char_num = len(record)\n\n        while right < len(f):\n            c = f[right][1]\n            if c in cur:\n                cur[c] += 1\n                matched += cur[c] == record[c]\n            while matched == char_num:\n                c = f[left][1]\n                if c in cur:\n                    cur[c] -= 1\n                    matched -= cur[c] < record[c]\n                if matched < char_num:\n                    real_right = f[right][0]\n                    real_left = f[left][0]\n                    if real_right - real_left + 1 < ans[0]:\n                        ans = (real_right - real_left + 1, real_left, real_right)\n                left += 1\n            right += 1\n            \n        return s[ans[1]:ans[2] + 1] if ans[0] <= len(s) else ''","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/minimum-window-substring/","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [x] can-optimize\n- [x] not-intuitive\n- [ ] bad-problem","Thinking":"I have come up with the sliding window method but found it difficult to implement."},"desc":"Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).\r\n\r\nExample:\r\n\r\n\r\nInput: S = \"ADOBECODEBANC\", T = \"ABC\"\r\nOutput: \"BANC\"\r\n\r\n\r\nNote:\r\n\r\n\r\n\tIf there is no such window in S that covers all characters in T, return the empty string \"\".\r\n\tIf there is such window, you are guaranteed that there will always be only one unique minimum window in S.\r\n\r\n"},{"index":642,"title":"Design Search Autocomplete System","body":{"mySolution":[],"optimizedSolution":[{"time":"$??$","space":"$??$","code":"// TODO: save disk usage\n// TODO: time and complexity analysis\n// TODO: using make_heap? list for priority queue?\ntypedef pair<string, int> PSI;\n\nclass TrieNode {\npublic:\n    unordered_map<char, TrieNode*> children;\n    bool isEnd;\n    int hitTimes;\n    TrieNode() : children(), isEnd(false), hitTimes(0) {};\n};\n\nclass NodeCompare\n{\npublic:\n    bool operator() (PSI& a, PSI& b)\n    {\n        if (a.second == b.second) {\n            return a.first.compare(b.first) > 0;\n        }\n        return a.second < b.second;\n    }\n};\n\ntypedef priority_queue<PSI, vector<PSI>, NodeCompare> PQPSI;\n\nclass AutocompleteSystem {\npublic:\n    TrieNode *root, *curNode;\n    string curString;\n    \n    AutocompleteSystem(vector<string>& sentences, vector<int>& times)\n        : curString(\"\")\n    {\n        root = new TrieNode();\n        curNode = root;\n        for (int i = 0; i < sentences.size(); i++) {\n            insert(sentences[i], times[i]);\n        }\n    }\n    \n    ~AutocompleteSystem() {\n        removePtr(root);\n    }\n    \n    void removePtr(TrieNode* node) {\n        for (auto it = node->children.begin(); it != node->children.end(); it++) {\n            removePtr(it->second);\n        }\n        delete node;\n    }\n    \n    void insert(string& sentence, int time) {\n        TrieNode* node = root;\n        for (int i = 0; i < sentence.size(); i++) {\n            char c = sentence[i];\n            if (node->children.find(c) == node->children.end()) {\n                node->children[c] = new TrieNode();\n            }\n            node = node->children[c];\n            if (i == sentence.size() - 1) {\n                node->isEnd = true;\n                node->hitTimes += time;\n            }\n        }\n    }\n    \n    vector<string> input(char c) {\n        if (c == '#') {\n            curNode->isEnd = true;\n            curNode->hitTimes += 1;\n            curString = \"\";\n            curNode = root;\n            return {};\n        }\n        // Not registered before\n        if (curNode->children.find(c) == curNode->children.end()) {\n            curNode->children[c] = new TrieNode();\n        }\n        curNode = curNode->children[c];\n        curString += c;\n        PQPSI pq;\n        dfs(curNode, curString, pq);\n        int i = 0;\n        vector<string> result;\n        while (i < 3 && !pq.empty()) {\n            result.push_back(pq.top().first);\n            pq.pop();\n            i++;\n        }\n        return result;\n    }\n    \n    void dfs(TrieNode* node, string str, PQPSI& pq) {\n        if (node->isEnd) {\n            pq.push(make_pair(str, node->hitTimes));\n        }\n        for (auto it = node->children.begin(); it != node->children.end(); it++) {\n            char c = it->first;\n            dfs(node->children[c], str + c, pq);\n        }\n    }\n};","language":"cpp"}],"anki":"","Link":"https://leetcode.com/problems/design-search-autocomplete-system/","Related":"","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [x] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem","Test Cases":""},"desc":"Design a search autocomplete system for a search engine. Users may input a sentence (at least one word and end with a special character '#'). For each character they type except '#', you need to return the top 3 historical hot sentences that have prefix the same as the part of sentence already typed. Here are the specific rules:\r\n\r\n\r\n\tThe hot degree for a sentence is defined as the number of times a user typed the exactly same sentence before.\r\n\tThe returned top 3 hot sentences should be sorted by hot degree (The first is the hottest one). If several sentences have the same degree of hot, you need to use ASCII-code order (smaller one appears first).\r\n\tIf less than 3 hot sentences exist, then just return as many as you can.\r\n\tWhen the input is a special character, it means the sentence ends, and in this case, you need to return an empty list.\r\n\r\n\r\nYour job is to implement the following functions:\r\n\r\nThe constructor function:\r\n\r\nAutocompleteSystem(String[] sentences, int[] times): This is the constructor. The input is historical data. Sentences is a string array consists of previously typed sentences. Times is the corresponding times a sentence has been typed. Your system should record these historical data.\r\n\r\nNow, the user wants to input a new sentence. The following function will provide the next character the user types:\r\n\r\nList<String> input(char c): The input c is the next character typed by the user. The character will only be lower-case letters ('a' to 'z'), blank space (' ') or a special character ('#'). Also, the previously typed sentence should be recorded in your system. The output will be the top 3 historical hot sentences that have prefix the same as the part of sentence already typed.\r\n \r\n\r\nExample:\r\nOperation: AutocompleteSystem([\"i love you\", \"island\",\"ironman\", \"i love leetcode\"], [5,3,2,2])\r\nThe system have already tracked down the following sentences and their corresponding times:\r\n\"i love you\" : 5 times\r\n\"island\" : 3 times\r\n\"ironman\" : 2 times\r\n\"i love leetcode\" : 2 times\r\nNow, the user begins another search:\r\n\r\nOperation: input('i')\r\nOutput: [\"i love you\", \"island\",\"i love leetcode\"]\r\nExplanation:\r\nThere are four sentences that have prefix \"i\". Among them, \"ironman\" and \"i love leetcode\" have same hot degree. Since ' ' has ASCII code 32 and 'r' has ASCII code 114, \"i love leetcode\" should be in front of \"ironman\". Also we only need to output top 3 hot sentences, so \"ironman\" will be ignored.\r\n\r\nOperation: input(' ')\r\nOutput: [\"i love you\",\"i love leetcode\"]\r\nExplanation:\r\nThere are only two sentences that have prefix \"i \".\r\n\r\nOperation: input('a')\r\nOutput: []\r\nExplanation:\r\nThere are no sentences that have prefix \"i a\".\r\n\r\nOperation: input('#')\r\nOutput: []\r\nExplanation:\r\nThe user finished the input, the sentence \"i a\" should be saved as a historical sentence in system. And the following input will be counted as a new search.\r\n \r\n\r\nNote:\r\n\r\n\r\n\tThe input sentence will always start with a letter and end with '#', and only one blank space will exist between two words.\r\n\tThe number of complete sentences that to be searched won't exceed 100. The length of each sentence including those in the historical data won't exceed 100.\r\n\tPlease use double-quote instead of single-quote when you write test cases even for a character input.\r\n\tPlease remember to RESET your class variables declared in class AutocompleteSystem, as static/class variables are persisted across multiple test cases. Please see here for more details.\r\n\r\n\r\n \r\n"},{"index":394,"title":"Decode String","body":{"mySolution":[{"time":"$O(N^2)$ in worst case","space":"$O(1)$","code":"class Solution:\n    def decodeString(self, s: str) -> str:\n        output = ''\n        i = 0\n        while i < len(s):\n            if s[i].isdigit():\n                numStart = i\n                # Be careful when the number is multi-digit\n                while s[i].isdigit():\n                    i += 1\n                num = int(s[numStart:i])\n                start = i\n                layer = 0\n                # Bracket in bracket\n                while i < len(s):\n                    if s[i] == '[':\n                        layer += 1\n                    elif s[i] == ']':\n                        layer -= 1\n                        if layer == 0:\n                            break\n                    i += 1\n\n                output += num * self.decodeString(s[start + 1:i])\n            else:\n                output += s[i]\n            \n            i += 1\n        \n        return output","language":"python"}],"optimizedSolution":[{"time":"$O(N)$","space":"$O(N)$","code":"class Solution:\n    def decodeString(self, s: str) -> str:\n        stack = [['', 1]]\n        num = ''\n        for c in s:\n            if c.isdigit():\n                num += c\n            elif c == '[':\n                stack.append(['', int(num)])\n                num = ''\n            elif c == ']':\n                st, times = stack.pop(-1)\n                stack[-1][0] += st * times\n            else:\n                stack[-1][0] += c\n        return stack[-1][0]","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/decode-string/","Solved":"- [x] solved\n- [ ] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [x] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem","Thinking":""},"desc":"Given an encoded string, return its decoded string.\n\nThe encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\n\nYou may assume that the input string is always valid; No extra white spaces, square brackets are well-formed, etc.\n\nFurthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there won't be input like 3a or 2[4].\n\nExamples:\n\n\ns = \"3[a]2[bc]\", return \"aaabcbc\".\ns = \"3[a2[c]]\", return \"accaccacc\".\ns = \"2[abc]3[cd]ef\", return \"abcabccdcdcdef\".\n\n\n \n"},{"index":236,"title":"Lowest Common Ancestor of a Binary Tree","body":{"mySolution":[{"time":"$O(N)$ where $N$ is the total number of nodes","space":"$O(N)$ in worst case, the depth is equal to the number of nodes","code":"class Solution:\n    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':\n        lowest = root\n        max_dep = 0\n        def hasPQ(node, depth):\n            if not node: return (False, False)\n            pl, ql = hasPQ(node.left, depth + 1)\n            pr, qr = hasPQ(node.right, depth + 1)\n            res = (node == p or pl or pr, node == q or ql or qr)\n            nonlocal max_dep\n            nonlocal lowest\n            if res[0] and res[1] and depth > max_dep:\n                max_dep = depth\n                lowest = node\n            return res\n        hasPQ(root, 0)\n        return lowest","language":"python"}],"optimizedSolution":[{"time":"$O(N)$","space":"$O(N)$","code":"class Solution:\n    def lowestCommonAncestor(self, root, p, q):\n        self.ans = root\n        def recurse_tree(current_node):\n\n            # If reached the end of a branch, return False.\n            if not current_node:\n                return False\n\n            # Left Recursion\n            left = recurse_tree(current_node.left)\n\n            # Right Recursion\n            right = recurse_tree(current_node.right)\n\n            # If the current node is one of p or q\n            mid = current_node == p or current_node == q\n\n            # If any two of the three flags left, right or mid become True.\n            if mid + left + right >= 2:\n                self.ans = current_node\n\n            # Return True if either of the three bool values is True.\n            return mid or left or right\n\n        # Traverse the tree\n        recurse_tree(root)\n        return self.ans","language":"python3"}],"anki":"","Link":"https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/","Solved":"- [x] solved\n- [ ] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [x] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem","Thinking":"What I thought about this problem"},"desc":"Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\r\n\r\nAccording to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”\r\n\r\nGiven the following binary tree:  root = [3,5,1,6,2,0,8,null,null,7,4]\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1\r\nOutput: 3\r\nExplanation: The LCA of nodes 5 and 1 is 3.\r\n\r\n\r\nExample 2:\r\n\r\n\r\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4\r\nOutput: 5\r\nExplanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition.\r\n\r\n\r\n \r\n\r\nNote:\r\n\r\n\r\n\tAll of the nodes' values will be unique.\r\n\tp and q are different and both values will exist in the binary tree.\r\n\r\n"},{"index":140,"title":"Word Break II","body":{"mySolution":[{"time":"$O(??)$","space":"$O(??)$","code":"# This got TLE\nfrom collections import defaultdict\n\nclass Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n        graph = defaultdict(list)\n        word_set = set(wordDict)\n        dp = [False] * (len(s) + 1)\n        dp[0] = True\n        # dp[j] represents whether s[:j] can be represented by the dict\n        # dp[0] is considered to be true\n        for i in range(len(s)):\n            for j in range(i + 1):\n                if dp[j] and s[j:i+1] in word_set:\n                    dp[i + 1] = True\n                    graph[j].append(i + 1)\n        \n        res = []\n        self.dfs(0, graph, s, [], res)\n        return res\n    \n    def dfs(self, current, graph, s, arr, res):\n        if current == len(s):\n            res.append(' '.join(arr))\n            return\n        \n        if current not in graph:\n            return\n        \n        for next in graph[current]:\n            arr.append(s[current:next])\n            self.dfs(next, graph, s, arr, res)\n            arr.pop()","language":"python"}],"optimizedSolution":[{"time":"$O(??)$","space":"$O(??)$","code":"class Solution:\n    def wordBreak(self, s, wordDict):\n        return self.helper(s, wordDict, {})\n\n    def helper(self, s, wordDict, memo):\n        if s in memo:\n            return memo[s]\n        \n        if len(s) == 0:\n            return ['']\n        \n        res = []\n        for word in wordDict:\n            if not s.startswith(word):\n                continue\n            if len(word) == len(s):\n                res.append(word)\n            else:\n                resultOfTheRest = self.helper(s[len(word):], wordDict, memo)\n                for item in resultOfTheRest:\n                    item = word + ' ' + item\n                    res.append(item)\n        memo[s] = res\n        return res","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/word-break-ii/","Related":"","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [x] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem","Test Cases":""},"desc":"Given a non-empty string s and a dictionary wordDict containing a list of non-empty words, add spaces in s to construct a sentence where each word is a valid dictionary word. Return all such possible sentences.\r\n\r\nNote:\r\n\r\n\r\n\tThe same word in the dictionary may be reused multiple times in the segmentation.\r\n\tYou may assume the dictionary does not contain duplicate words.\r\n\r\n\r\nExample 1:\r\n\r\n\r\nInput:\r\ns = \"catsanddog\"\r\nwordDict = [\"cat\", \"cats\", \"and\", \"sand\", \"dog\"]\r\nOutput:\r\n[\r\n  \"cats and dog\",\r\n  \"cat sand dog\"\r\n]\r\n\r\n\r\nExample 2:\r\n\r\n\r\nInput:\r\ns = \"pineapplepenapple\"\r\nwordDict = [\"apple\", \"pen\", \"applepen\", \"pine\", \"pineapple\"]\r\nOutput:\r\n[\r\n  \"pine apple pen apple\",\r\n  \"pineapple pen apple\",\r\n  \"pine applepen apple\"\r\n]\r\nExplanation: Note that you are allowed to reuse a dictionary word.\r\n\r\n\r\nExample 3:\r\n\r\n\r\nInput:\r\ns = \"catsandog\"\r\nwordDict = [\"cats\", \"dog\", \"sand\", \"and\", \"cat\"]\r\nOutput:\r\n[]\r\n"},{"index":314,"title":"Binary Tree Vertical Order Traversal","body":{"mySolution":[{"time":"$O(N)$","space":"$O(N)$","code":"from collections import deque\n\nclass Solution:\n    def verticalOrder(self, root: TreeNode) -> List[List[int]]:\n        if not root:\n            return []\n        left = []\n        mid = []\n        right = []\n        q = deque([(root, 0)])\n        while q:\n            node, col = q.popleft()\n            if col == 0:\n                mid.append(node.val)\n            else:\n                target = right\n                ind = col\n                if col < 0:\n                    target = left\n                    ind = -col\n                if len(target) < ind:\n                    target.append([])\n                \n                target[ind - 1].append(node.val)\n            \n            if node.left:\n                q.append((node.left, col - 1))\n                \n            if node.right:\n                q.append((node.right, col + 1))\n                \n        left.reverse()\n        return left + [mid] + right\n        ","language":"python"}],"optimizedSolution":[],"anki":"","Link":"https://leetcode.com/problems/binary-tree-vertical-order-traversal/","Related":"","Solved":"- [x] solved\n- [ ] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [x] fully-master\n- [ ] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem","Test Cases":""},"desc":"Given a binary tree, return the vertical order traversal of its nodes' values. (ie, from top to bottom, column by column).\r\n\r\nIf two nodes are in the same row and column, the order should be from left to right.\r\n\r\nExamples 1:\r\n\r\n\r\nInput: [3,9,20,null,null,15,7]\r\n\r\n   3\r\n  /\\\r\n /  \\\r\n 9  20\r\n    /\\\r\n   /  \\\r\n  15   7 \r\n\r\nOutput:\r\n\r\n[\r\n  [9],\r\n  [3,15],\r\n  [20],\r\n  [7]\r\n]\r\n\r\n\r\nExamples 2:\r\n\r\n\r\nInput: [3,9,8,4,0,1,7]\r\n\r\n     3\r\n    /\\\r\n   /  \\\r\n   9   8\r\n  /\\  /\\\r\n /  \\/  \\\r\n 4  01   7 \r\n\r\nOutput:\r\n\r\n[\r\n  [4],\r\n  [9],\r\n  [3,0,1],\r\n  [8],\r\n  [7]\r\n]\r\n\r\n\r\nExamples 3:\r\n\r\n\r\nInput: [3,9,8,4,0,1,7,null,null,null,2,5] (0's right child is 2 and 1's left child is 5)\r\n\r\n     3\r\n    /\\\r\n   /  \\\r\n   9   8\r\n  /\\  /\\\r\n /  \\/  \\\r\n 4  01   7\r\n    /\\\r\n   /  \\\r\n   5   2\r\n\r\nOutput:\r\n\r\n[\r\n  [4],\r\n  [9,5],\r\n  [3,0,1],\r\n  [8,2],\r\n  [7]\r\n]\r\n\r\n"},{"index":739,"title":"Daily Temperatures","body":{"mySolution":[{"time":"$O(N)$","space":"$O(N)$","code":"class Solution:\n    def dailyTemperatures(self, T: List[int]) -> List[int]:\n        stack = []\n        res = [0] * len(T)\n        # The stack keeps track of the last peak\n        # and anything after the peak\n        for i in range(len(T) - 1, -1, -1):\n            # We will discard anything before the peak since it cannot be the next warmer day\n            while stack and T[stack[-1]] <= T[i]:\n                stack.pop()\n            if stack:\n                res[i] = stack[-1] - i\n\n            stack.append(i)\n        return res","language":"python"}],"optimizedSolution":[],"anki":"","Link":"https://leetcode.com/problems/daily-temperatures/","Solved":"- [x] solved\n- [ ] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [ ] can-optimize\n- [x] not-intuitive\n- [ ] bad-problem","Thinking":""},"desc":"\r\nGiven a list of daily temperatures T, return a list such that, for each day in the input, tells you how many days you would have to wait until a warmer temperature.  If there is no future day for which this is possible, put 0 instead.\r\n\r\nFor example, given the list of temperatures T = [73, 74, 75, 71, 69, 72, 76, 73], your output should be [1, 1, 4, 2, 1, 1, 0, 0].\r\n\r\n\r\nNote:\r\nThe length of temperatures will be in the range [1, 30000].\r\nEach temperature will be an integer in the range [30, 100].\r\n"},{"index":89,"title":"Gray Code","body":{"mySolution":[{"time":"$O(2^N)$","space":"$O(N)$","code":"class Solution:\n    # Recursive\n    def grayCode(self, n: int) -> List[int]:\n        if n == 0:\n            return [0]\n        t = 1 << (n - 1)\n        l =  self.grayCode(n - 1) + [0] * t\n        for i in range(t):\n            l[-i - 1] = l[i] + t\n        return l","language":"python"},{"time":"$O(2^N)$","space":"$O(N)$","code":"class Solution:\n    # Iterative\n    def grayCode(self, n: int) -> List[int]:\n        res = [0] * (1 << n)\n        if n == 0:\n            return res\n        for i in range(n):\n            power = 1 << i\n            for j in range(power):\n                res[j + power] = res[power - 1 - j] + power\n        return res","language":"python"}],"optimizedSolution":[{"time":"$O(N)$","space":"$O(N^2)$","code":"Post the optimized solution after looking at the solution. ","language":""}],"anki":"","Link":"https://leetcode.com/problems/gray-code/","Solved":"- [x] solved\n- [ ] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [x] fully-master\n- [ ] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem","Thinking":""},"desc":"The gray code is a binary numeral system where two successive values differ in only one bit.\r\n\r\nGiven a non-negative integer n representing the total number of bits in the code, print the sequence of gray code. A gray code sequence must begin with 0.\r\n\r\nExample 1:\r\n\r\n\r\nInput: 2\r\nOutput: [0,1,3,2]\r\nExplanation:\r\n00 - 0\r\n01 - 1\r\n11 - 3\r\n10 - 2\r\n\r\nFor a given n, a gray code sequence may not be uniquely defined.\r\nFor example, [0,2,3,1] is also a valid gray code sequence.\r\n\r\n00 - 0\r\n10 - 2\r\n11 - 3\r\n01 - 1\r\n\r\n\r\nExample 2:\r\n\r\n\r\nInput: 0\r\nOutput: [0]\r\nExplanation: We define the gray code sequence to begin with 0.\r\n             A gray code sequence of n has size = 2^n, which for n = 0 the size is 2^0 = 1.\r\n             Therefore, for n = 0 the gray code sequence is [0].\r\n\r\n"},{"index":49,"title":"Group Anagrams","body":{"mySolution":[],"optimizedSolution":[{"time":"$O(N * K)$ where $K$ is the maximum length of each str","space":"$O(N)$","code":"class Solution(object):\n    def groupAnagrams(self, strs):\n        ans = collections.defaultdict(list)\n        for s in strs:\n            count = [0] * 26\n            for c in s:\n                count[ord(c) - ord('a')] += 1\n            ans[tuple(count)].append(s)\n        return ans.values()\n        ","language":"python"}],"anki":"The key is find a way to store the number that each letter appears. Different data structures will be used in different languages\n1. For python, we could use a defaultlist(dict) with tuple of length 26 as the key\n2. For cpp, we could use a string of counts separated by '#' as the key","Link":"https://leetcode.com/problems/group-anagrams/","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [x] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem"},"desc":"Given an array of strings, group anagrams together.\r\n\r\nExample:\r\n\r\n\r\nInput: [\"eat\", \"tea\", \"tan\", \"ate\", \"nat\", \"bat\"],\r\nOutput:\r\n[\r\n  [\"ate\",\"eat\",\"tea\"],\r\n  [\"nat\",\"tan\"],\r\n  [\"bat\"]\r\n]\r\n\r\nNote:\r\n\r\n\r\n\tAll inputs will be in lowercase.\r\n\tThe order of your output does not matter.\r\n\r\n"},{"index":96,"title":"Unique Binary Search Trees","body":{"mySolution":[{"time":"$O(N)$","space":"$O(N^2)$","code":"class Solution:\n    def numTrees(self, n: int) -> int:\n        dp = [0] * (n + 1)\n        dp[0] = dp[1] = 1\n        for i in range(2, n + 1):\n            half_i = i // 2\n            for j in range(0, half_i):\n                dp[i] += 2 * dp[j] * dp[i - 1 - j]\n            dp[i] += (i % 2) * dp[half_i] * dp[half_i]\n        return dp[n]","language":"python"}],"optimizedSolution":[],"anki":"","Link":"https://leetcode.com/problems/unique-binary-search-trees/","Solved":"- [x] solved\n- [ ] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [x] fully-master\n- [ ] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem"},"desc":"Given n, how many structurally unique BST's (binary search trees) that store values 1 ... n?\r\n\r\nExample:\r\n\r\n\r\nInput: 3\r\nOutput: 5\r\nExplanation:\r\nGiven n = 3, there are a total of 5 unique BST's:\r\n\r\n   1         3     3      2      1\r\n    \\       /     /      / \\      \\\r\n     3     2     1      1   3      2\r\n    /     /       \\                 \\\r\n   2     1         2                 3\r\n\r\n"},{"index":416,"title":"Partition Equal Subset Sum","body":{"mySolution":[{"time":"","space":"","code":"","language":""}],"optimizedSolution":[{"time":"$O(N)$","space":"$O(N^2)$","code":"class Solution(object):\n    def canPartition(self, nums):\n        sum_val = sum(nums)\n        if sum_val % 2 == 1:\n            return False\n        target = sum_val // 2\n        # We use dp[j] to store whether j can be summed to\n        dp = [False] * (sum_val + 1)\n        dp[0] = True\n        for num in nums:\n            next_dp = [False] * (sum_val + 1)\n            for j in xrange(len(dp)):\n                if dp[j]:\n                    next_dp[j + num] = True\n                    next_dp[j] = True\n            dp = next_dp\n        return dp[target]","language":""},{"time":"$O(N)$","space":"$O(S)$ where $S$ is the sum of the array","code":"class Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        s = 0\n        b = 1\n        for n in nums:\n            s += n\n            b |= b << n\n        if s % 2 == 1:\n            return False\n        return (b >> s // 2) & 1 == 1","language":""}],"anki":"","Link":"https://leetcode.com/problems/partition-equal-subset-sum/","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [x] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem","Thinking":""},"desc":"Given a non-empty array containing only positive integers, find if the array can be partitioned into two subsets such that the sum of elements in both subsets is equal.\r\n\r\nNote:\r\n\r\n\r\n\tEach of the array element will not exceed 100.\r\n\tThe array size will not exceed 200.\r\n\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: [1, 5, 11, 5]\r\n\r\nOutput: true\r\n\r\nExplanation: The array can be partitioned as [1, 5, 5] and [11].\r\n\r\n\r\n \r\n\r\nExample 2:\r\n\r\n\r\nInput: [1, 2, 3, 5]\r\n\r\nOutput: false\r\n\r\nExplanation: The array cannot be partitioned into equal sum subsets.\r\n\r\n\r\n \r\n"},{},{"index":138,"title":"Copy List with Random Pointer","body":{"mySolution":[{"time":"$O(N)$","space":"$O(1)$","code":"\"\"\"\n# Definition for a Node.\nclass Node:\n    def __init__(self, val, next, random):\n        self.val = val\n        self.next = next\n        self.random = random\n\"\"\"\nclass Solution:\n    def copyRandomList(self, head: 'Node') -> 'Node':\n        dummy = node = Node(None, None, None)\n        while head:\n            node.next = Node(head.val, head.next, head.random)\n            node = node.next\n            head.copy = node\n            head = head.next\n        \n        node = dummy.next\n        while node:\n            if node.random:\n                node.random = node.random.copy\n            node = node.next\n        \n        return dummy.next","language":"python"}],"optimizedSolution":[{"time":"$O(N)$","space":"$O(N)$","code":"","language":""}],"anki":"","Link":"https://leetcode.com/problems/copy-list-with-random-pointer/","Solved":"- [x] solved\n- [ ] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [x] fully-master\n- [ ] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem","Thinking":""},"desc":"A linked list is given such that each node contains an additional random pointer which could point to any node in the list or null.\r\n\r\nReturn a deep copy of the list.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\n\r\n\r\nInput:\r\n{\"$id\":\"1\",\"next\":{\"$id\":\"2\",\"next\":null,\"random\":{\"$ref\":\"2\"},\"val\":2},\"random\":{\"$ref\":\"2\"},\"val\":1}\r\n\r\nExplanation:\r\nNode 1's value is 1, both of its next and random pointer points to Node 2.\r\nNode 2's value is 2, its next pointer points to null and its random pointer points to itself.\r\n\r\n\r\n \r\n\r\nNote:\r\n\r\n\r\n\tYou must return the copy of the given head as a reference to the cloned list.\r\n\r\n"},{"index":560,"title":"Subarray Sum Equals K","body":{"mySolution":[{"time":"","space":"","code":"","language":""}],"optimizedSolution":[{"time":"$O(N)$","space":"$O(N)$","code":"class Solution:\n    def subarraySum(self, nums: List[int], k: int) -> int:\n        m = { 0: 1 }\n        s = count = 0\n        for n in nums:\n            s += n\n            # sum(i, j) = cum(j) - cum(i)j\n            if s - k in m:\n                count += m[s - k]\n            # Store the count of cumulative sums in the dict\n            m[s] = m.get(s, 0) + 1\n\n        return count","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/subarray-sum-equals-k/","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [ ] can-optimize\n- [x] not-intuitive\n- [ ] bad-problem","Thinking":""},"desc":"Given an array of integers and an integer k, you need to find the total number of continuous subarrays whose sum equals to k.\r\n\r\nExample 1:\r\n\r\nInput:nums = [1,1,1], k = 2\r\nOutput: 2\r\n\r\n\r\n\r\nNote:\r\n\r\nThe length of the array is in range [1, 20,000].\r\nThe range of numbers in the array is [-1000, 1000] and the range of the integer k is [-1e7, 1e7].\r\n\r\n\r\n"},{"index":72,"title":"Edit Distance","body":{"mySolution":[{"time":"$O(N * M)$ where $N$ and $M$ are the lengths of the two words respectively","space":"$O(N * M)$","code":"class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        l1 = len(word1)\n        l2 = len(word2)\n\n        dp = [[0] * (l2 + 1) for _ in range(l1 + 1)]\n\n        for i in range(l1 + 1): dp[i][0] = i\n        for j in range(l2 + 1): dp[0][j] = j\n\n        for i in range(1, l1 + 1):\n            for j in range(1, l2 + 1):\n                addition = dp[i][j - 1] + 1\n                deletion = dp[i - 1][j] + 1\n                replace = dp[i - 1][j - 1]\n                if word1[i - 1] != word2[j - 1]:\n                    replace += 1\n                dp[i][j] = min(addition, deletion, replace)\n\n        return dp[l1][l2]","language":"python"}],"optimizedSolution":[{"time":"$O(N * M)$","space":"$O(min(N, M))$","code":"class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        if len(word2) > len(word1):\n            word1, word2 = word2, word1\n  \n        l1 = len(word1)\n        l2 = len(word2)\n\n        dp = [0] * (l2 + 1)\n\n        for j in range(l2 + 1): dp[j] = j\n\n        for i in range(1, l1 + 1):\n            temp = dp[0]\n            dp[0] = i\n            for j in range(1, l2 + 1):\n                addition = dp[j - 1] + 1\n                deletion = dp[j] + 1\n                replace = temp\n                if word1[i - 1] != word2[j - 1]:\n                    replace += 1\n                temp = dp[j]\n                dp[j] = min(addition, deletion, replace)\n\n        return dp[l2]","language":"python"}],"anki":"This problem is solved by dynamic programming. Consider two words, `w1` with length `l1` and `w2` with length `l2`. We use a matrix of size `(l1 + 1) * (l2 + 1)`, with each cell `dp[i][j]` representing the minimum number of operations to transform the first `i` letters of `w1` to first `j` letters of `w2`. We offset the number of rows and columns by 1 to represent the empty string.\n\nNotice that when iterating through each row of the matrix, we are only using the cells in the row above and one cell before. So it is possible to optimize the space usage to only an 1-D array of size `min(l1, l2)`, since the count of operations from is symmetric for `w1` and `w2`.","Link":"https://leetcode.com/problems/edit-distance/","Solved":"- [x] solved\n- [ ] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [x] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem"},"desc":"Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.\r\n\r\nYou have the following 3 operations permitted on a word:\r\n\r\n\r\n\tInsert a character\r\n\tDelete a character\r\n\tReplace a character\r\n\r\n\r\nExample 1:\r\n\r\n\r\nInput: word1 = \"horse\", word2 = \"ros\"\r\nOutput: 3\r\nExplanation: \r\nhorse -> rorse (replace 'h' with 'r')\r\nrorse -> rose (remove 'r')\r\nrose -> ros (remove 'e')\r\n\r\n\r\nExample 2:\r\n\r\n\r\nInput: word1 = \"intention\", word2 = \"execution\"\r\nOutput: 5\r\nExplanation: \r\nintention -> inention (remove 't')\r\ninention -> enention (replace 'i' with 'e')\r\nenention -> exention (replace 'n' with 'x')\r\nexention -> exection (replace 'n' with 'c')\r\nexection -> execution (insert 'u')\r\n\r\n"},{"index":34,"title":"Find First and Last Position of Element in Sorted Array","body":{"mySolution":[],"optimizedSolution":[],"anki":""},"desc":"Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.\r\n\r\nYour algorithm's runtime complexity must be in the order of O(log n).\r\n\r\nIf the target is not found in the array, return [-1, -1].\r\n\r\nExample 1:\r\n\r\n\r\nInput: nums = [5,7,7,8,8,10], target = 8\r\nOutput: [3,4]\r\n\r\nExample 2:\r\n\r\n\r\nInput: nums = [5,7,7,8,8,10], target = 6\r\nOutput: [-1,-1]\r\n"},{"index":128,"title":"Longest Consecutive Sequence","body":{"mySolution":[],"optimizedSolution":[{"time":"$O(N)$","space":"$O(N)$","code":"class Solution:\n    def longestConsecutive(self, nums: List[int]) -> int:\n        s = set(nums)\n        longest = 0\n        for n in s:\n            if n - 1 not in s:\n                cur = n\n                cur_len = 1\n                while cur + 1 in s:\n                    cur += 1\n                    cur_len += 1\n                longest = max(cur_len, longest)\n        return longest","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/longest-consecutive-sequence/","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [ ] can-optimize\n- [x] not-intuitive\n- [ ] bad-problem"},"desc":"Given an unsorted array of integers, find the length of the longest consecutive elements sequence.\r\n\r\nYour algorithm should run in O(n) complexity.\r\n\r\nExample:\r\n\r\n\r\nInput: [100, 4, 200, 1, 3, 2]\r\nOutput: 4\r\nExplanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4.\r\n\r\n"},{"index":1048,"title":"Longest String Chain","body":{"mySolution":[],"optimizedSolution":[],"anki":""},"desc":"Given a list of words, each word consists of English lowercase letters.\r\n\r\nLet's say word1 is a predecessor of word2 if and only if we can add exactly one letter anywhere in word1 to make it equal to word2.  For example, \"abc\" is a predecessor of \"abac\".\r\n\r\nA word chain is a sequence of words [word_1, word_2, ..., word_k] with k >= 1, where word_1 is a predecessor of word_2, word_2 is a predecessor of word_3, and so on.\r\n\r\nReturn the longest possible length of a word chain with words chosen from the given list of words.\r\n\r\n \r\n\r\nExample 1:\r\n\r\n\r\nInput: [\"a\",\"b\",\"ba\",\"bca\",\"bda\",\"bdca\"]\r\nOutput: 4\r\nExplanation: one of the longest word chain is \"a\",\"ba\",\"bda\",\"bdca\".\r\n\r\n\r\n \r\n\r\nNote:\r\n\r\n\r\n\t1 <= words.length <= 1000\r\n\t1 <= words[i].length <= 16\r\n\twords[i] only consists of English lowercase letters.\r\n\r\n\r\n\r\n \r\n"},{"index":215,"title":"Kth Largest Element in an Array","body":{"mySolution":[{"time":"$O(kN)$","space":"$O(k)$","code":"class Solution:\n    def findKthLargest(self, nums: List[int], k: int) -> int:\n        k_max = [float('-inf')] * k\n        for n in nums:\n            if n > k_max[0]:\n                k_max[0] = n\n            for i in range(1, k):\n                if n > k_max[i]:\n                    k_max[i], k_max[i - 1] = k_max[i - 1], k_max[i]\n                else:\n                    break\n        return k_max[0]\n                    ","language":""}],"optimizedSolution":[{"time":"$O(N)$","space":"$O(N^2)$","code":"Post the optimized solution after looking at the solution. ","language":""}],"anki":"","Link":"https://leetcode.com/problems/kth-largest-element-in-an-array/","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [ ] can-optimize\n- [ ] not-intuitive\n- [ ] bad-problem"},"desc":"Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.\r\n\r\nExample 1:\r\n\r\n\r\nInput: [3,2,1,5,6,4] and k = 2\r\nOutput: 5\r\n\r\n\r\nExample 2:\r\n\r\n\r\nInput: [3,2,3,1,2,4,5,5,6] and k = 4\r\nOutput: 4\r\n\r\nNote: \r\nYou may assume k is always valid, 1 ≤ k ≤ array's length.\r\n"},{"index":45,"title":"Jump Game II","body":{"mySolution":[],"optimizedSolution":[],"anki":""},"desc":"Given an array of non-negative integers, you are initially positioned at the first index of the array.\r\n\r\nEach element in the array represents your maximum jump length at that position.\r\n\r\nYour goal is to reach the last index in the minimum number of jumps.\r\n\r\nExample:\r\n\r\n\r\nInput: [2,3,1,1,4]\r\nOutput: 2\r\nExplanation: The minimum number of jumps to reach the last index is 2.\r\n    Jump 1 step from index 0 to 1, then 3 steps to the last index.\r\n\r\nNote:\r\n\r\nYou can assume that you can always reach the last index.\r\n"},{"index":1186,"title":"Maximum Subarray Sum with One Deletion","body":{"mySolution":[],"optimizedSolution":[{"time":"$O(N)$","space":"$O(1)$","code":"# Using Kadane's algorithm\nclass Solution:\n    def maximumSum(self, arr: List[int]) -> int:\n        gmax = max_ele = arr[0]\n        not_ignored = ignored = 0\n        for a in arr:\n            # not_ignored is the max subarray-sum without ignoring elements\n            not_ignored = max(a, not_ignored + a)\n            # ignored is the max subarray-sum that must has one element ignored\n            # two choices: 1. ignore the current one 2.include the current one\n            ignored = max(ignored + a, not_ignored - a)\n            # global max is obtained by either ignoring element or not\n            gmax = max(gmax, ignored, not_ignored)\n            # at the mean time, we pick the max element\n            max_ele = max(max_ele, a)\n        # If all elements are < 0, since our subarray cannot be empty, our gmax will give 0\n        # If there is one positive element, gmax will try including it\n        # So we return the maximum element if all are negative\n        return max_ele if max_ele < 0 else gmax","language":"python"}],"anki":"","Link":"https://leetcode.com/problems/maximum-subarray-sum-with-one-deletion/","Related":"","Solved":"- [ ] solved\n- [x] by-discussion\n- [ ] no-idea\n- [ ] later","Status":"- [ ] fully-master\n- [ ] can-optimize\n- [x] not-intuitive\n- [ ] bad-problem","Test Cases":""},"desc":""},{"index":1072,"title":"Flip Columns For Maximum Number of Equal Rows","body":{"mySolution":[],"optimizedSolution":[],"anki":""},"desc":"Given a matrix consisting of 0s and 1s, we may choose any number of columns in the matrix and flip every cell in that column.  Flipping a cell changes the value of that cell from 0 to 1 or from 1 to 0.\r\n\r\nReturn the maximum number of rows that have all values equal after some number of flips.\r\n\r\n \r\n\r\n\r\n\r\n\r\n\r\nExample 1:\r\n\r\n\r\nInput: [[0,1],[1,1]]\r\nOutput: 1\r\nExplanation: After flipping no values, 1 row has all values equal.\r\n\r\n\r\n\r\nExample 2:\r\n\r\n\r\nInput: [[0,1],[1,0]]\r\nOutput: 2\r\nExplanation: After flipping values in the first column, both rows have equal values.\r\n\r\n\r\n\r\nExample 3:\r\n\r\n\r\nInput: [[0,0,0],[0,0,1],[1,1,0]]\r\nOutput: 2\r\nExplanation: After flipping values in the first two columns, the last two rows have equal values.\r\n\r\n\r\n \r\n\r\nNote:\r\n\r\n\r\n\t1 <= matrix.length <= 300\r\n\t1 <= matrix[i].length <= 300\r\n\tAll matrix[i].length's are equal\r\n\tmatrix[i][j] is 0 or 1\r\n\r\n\r\n\r\n"},{}]}