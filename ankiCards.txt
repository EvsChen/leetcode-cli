10 	 <div>10. Regular Expression Matching</div><div>Given an input string (s) and a pattern (p), implement regular expression matching with support for '.' and '*'.</div><div></div><div>'.' Matches any single character.</div><div>'*' Matches zero or more of the preceding element.</div><div></div><div>The matching should cover the entire input string (not partial).</div><div></div><div>Note:</div><div></div><div>&nbsp;&nbsp;s could be empty and contains only lowercase letters a-z.</div><div>&nbsp;&nbsp;p could be empty and contains only lowercase letters a-z, and characters like . or *.</div><div></div><div>Example 1:</div><div></div><div>Input:</div><div>s = "aa"</div><div>p = "a"</div><div>Output: false</div><div>Explanation: "a" does not match the entire string "aa".</div><div></div><div>Example 2:</div><div></div><div>Input:</div><div>s = "aa"</div><div>p = "a*"</div><div>Output: true</div><div>Explanation: '*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes "aa".</div><div></div><div>Example 3:</div><div></div><div>Input:</div><div>s = "ab"</div><div>p = ".*"</div><div>Output: true</div><div>Explanation: ".*" means "zero or more (*) of any character (.)".</div><div></div><div>Example 4:</div><div></div><div>Input:</div><div>s = "aab"</div><div>p = "c*a*b"</div><div>Output: true</div><div>Explanation: c can be repeated 0 times, a can be repeated 1 time. Therefore, it matches "aab".</div><div></div><div>Example 5:</div><div></div><div>Input:</div><div>s = "mississippi"</div><div>p = "mis*is*p*."</div><div>Output: false</div><div></div> 	 <div>Use 2d dynamic programming, where <code>dp[i][j]</code> represents whether <code>s[:i]</code> and <code>p[:j]</code> match each other. Matrix size is one more than the length of str and pattern to handle boudary conditions.</div>
4 	 <div>4. Median of Two Sorted Arrays</div><div>There are two sorted arrays nums1 and nums2 of size m and n respectively.</div><div></div><div>Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).</div><div></div><div>You may assume nums1 and nums2 cannot be both empty.</div><div></div><div>Example 1:</div><div></div><div>nums1 = [1, 3]</div><div>nums2 = [2]</div><div></div><div>The median is 2.0</div><div></div><div>Example 2:</div><div></div><div>nums1 = [1, 2]</div><div>nums2 = [3, 4]</div><div></div><div>The median is (2 + 3)/2 = 2.5</div><div></div> 	 <div>Binary search in the longer array. Watch for corner cases and the start and end of search range.</div>
15 	 <div>15. 3Sum</div><div>Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? Find all unique triplets in the array which gives the sum of zero.</div><div></div><div>Note:</div><div></div><div>The solution set must not contain duplicate triplets.</div><div></div><div>Example:</div><div></div><div>Given array nums = [-1, 0, 1, 2, -1, -4],</div><div></div><div>A solution set is:</div><div>[</div><div>  [-1, 0, 1],</div><div>  [-1, -1, 2]</div><div>]</div><div></div> 	 <div>Sort first. Use two pointers to approach to the middle. Use a while loop to avoid repetitive solution.</div>
42 	 <div>42. Trapping Rain Water</div><div>Given n non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.</div><div></div><div>The above elevation map is represented by array [0,1,0,2,1,0,1,3,2,1,2,1]. In this case, 6 units of rain water (blue section) are being trapped. Thanks Marcos for contributing this image!</div><div></div><div>Example:</div><div></div><div>Input: [0,1,0,2,1,0,1,3,2,1,2,1]</div><div>Output: 6</div><div></div> 	 <div>Three methods can be used to solve this problem. And all three can be done within linear time.</div><div>1. Using stack. We are tring to catch the 'V' pattern in the histogram. And a stack is used to store the left side of 'V'. We ignore the case when decreasing or increasing when stack is empty. For the other cases, the water that a column can retain is calculated by the vertical bar formed with the left bounds that are smaller than it.</div><div>2. Dynamic programming. Suppose you're standing on one of the bar. Look left, the highest bar is <code>maxleft[i]</code>. The <code>maxright[i]</code> is defined the same. The water that can finally be "stored" on top of the bar is decided by the minimum of the left/right boundary. So we store the <code>maxleft</code> and <code>maxright</code> at each bar. And accumulate the value by using <code>min(left, right) - height[i]</code>.</div><div>3. Method 2 can be optimized by only using constant space and two pointers. Use <code>maxleft</code> and <code>maxright</code> to store the maximum up to now. When <code>height[left] < height[right]</code>, <code>height[left]</code> is able to keep water if <code>maxleft > height[left]</code>. So we accululate the <code>maxleft - height[left]</code> each time. Same for the right side.</div>
1 	 <div>1. Two Sum</div><div>Given an array of integers, return indices of the two numbers such that they add up to a specific target.</div><div></div><div>You may assume that each input would have exactly one solution, and you may not use the same element twice.</div><div></div><div>Example:</div><div></div><div>Given nums = [2, 7, 11, 15], target = 9,</div><div></div><div>Because nums[0] + nums[1] = 2 + 7 = 9,</div><div>return [0, 1].</div><div></div> 	 <div>Use hash to search for another number</div>
70 	 <div>70. Climbing Stairs</div><div>You are climbing a stair case. It takes n steps to reach to the top.</div><div></div><div>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</div><div></div><div>Note: Given n will be a positive integer.</div><div></div><div>Example 1:</div><div></div><div>Input: 2</div><div>Output: 2</div><div>Explanation: There are two ways to climb to the top.</div><div>1. 1 step + 1 step</div><div>2. 2 steps</div><div></div><div>Example 2:</div><div></div><div>Input: 3</div><div>Output: 3</div><div>Explanation: There are three ways to climb to the top.</div><div>1. 1 step + 1 step + 1 step</div><div>2. 1 step + 2 steps</div><div>3. 2 steps + 1 step</div><div></div> 	 <div>Dynamic programming</div>
48 	 <div>48. Rotate Image</div><div>You are given an n x n 2D matrix representing an image.</div><div></div><div>Rotate the image by 90 degrees (clockwise).</div><div></div><div>Note:</div><div></div><div>You have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.</div><div></div><div>Example 1:</div><div></div><div>Given input matrix = </div><div>[</div><div>  [1,2,3],</div><div>  [4,5,6],</div><div>  [7,8,9]</div><div>],</div><div></div><div>rotate the input matrix in-place such that it becomes:</div><div>[</div><div>  [7,4,1],</div><div>  [8,5,2],</div><div>  [9,6,3]</div><div>]</div><div></div><div>Example 2:</div><div></div><div>Given input matrix =</div><div>[</div><div>  [ 5, 1, 9,11],</div><div>  [ 2, 4, 8,10],</div><div>  [13, 3, 6, 7],</div><div>  [15,14,12,16]</div><div>], </div><div></div><div>rotate the input matrix in-place such that it becomes:</div><div>[</div><div>  [15,13, 2, 5],</div><div>  [14, 3, 4, 1],</div><div>  [12, 6, 8, 9],</div><div>  [16, 7,10,11]</div><div>]</div><div></div> 	 <div>1. Dealing four symmtric points at a time. Cycle between the four</div><div>2. Transpose and reverse row</div>
2 	 <div>2. Add Two Numbers</div><div>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</div><div></div><div>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</div><div></div><div>Example:</div><div></div><div>Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)</div><div>Output: 7 -> 0 -> 8</div><div>Explanation: 342 + 465 = 807.</div><div></div> 	 <div>Use a <code>carrier</code> and dummy head</div>
5 	 <div>5. Longest Palindromic Substring</div><div>Given a string s, find the longest palindromic substring in s. You may assume that the maximum length of s is 1000.</div><div></div><div>Example 1:</div><div></div><div>Input: "babad"</div><div>Output: "bab"</div><div>Note: "aba" is also a valid answer.</div><div></div><div>Example 2:</div><div></div><div>Input: "cbbd"</div><div>Output: "bb"</div><div></div> 	 <div>Expand from center.</div>
46 	 <div>46. Permutations</div><div>Given a collection of distinct integers, return all possible permutations.</div><div></div><div>Example:</div><div></div><div>Input: [1,2,3]</div><div>Output:</div><div>[</div><div>  [1,2,3],</div><div>  [1,3,2],</div><div>  [2,1,3],</div><div>  [2,3,1],</div><div>  [3,1,2],</div><div>  [3,2,1]</div><div>]</div><div></div> 	 <div>Recursive solution. For a list <code>nums</code>, and a permutation functin <code>permute()</code>, the whole set of permutation can be considered as:</div><div>- \([nums[0], permute(nums[1:])]\)</div><div>- \([nums[1], permute(nums[0] + nums[2:])]\)</div><div>- \([nums[2], permute(nums[0, 1] + nums[3:])]\)</div><div></div><div>So we swap the \(i\)th number of the list with the <code>begin</code>, and then permute the rest. If <code>begin</code> is equal to <code>len(nums) - 1</code>, we'll create a copy of the list and push it into the result.</div><div></div><div>Since a list of length \(N\) has \(N!\) permutations, the time complexity must be \(O(N!)\). Clearly the space complexity is \(O(1)\).</div>
49 	 <div>49. Group Anagrams</div><div>Given an array of strings, group anagrams together.</div><div></div><div>Example:</div><div></div><div>Input: ["eat", "tea", "tan", "ate", "nat", "bat"],</div><div>Output:</div><div>[</div><div>  ["ate","eat","tea"],</div><div>  ["nat","tan"],</div><div>  ["bat"]</div><div>]</div><div></div><div>Note:</div><div></div><div>&nbsp;&nbsp;All inputs will be in lowercase.</div><div>&nbsp;&nbsp;The order of your output does not matter.</div><div></div> 	 <div>The key is find a way to store the number that each letter appears. Different data structures will be used in different languages</div><div>1. For python, we could use a defaultlist(dict) with tuple of length 26 as the key</div><div>2. For cpp, we could use a string of counts separated by '#' as the key</div>
72 	 <div>72. Edit Distance</div><div>Given two words word1 and word2, find the minimum number of operations required to convert word1 to word2.</div><div></div><div>You have the following 3 operations permitted on a word:</div><div></div><div>&nbsp;&nbsp;Insert a character</div><div>&nbsp;&nbsp;Delete a character</div><div>&nbsp;&nbsp;Replace a character</div><div></div><div>Example 1:</div><div></div><div>Input: word1 = "horse", word2 = "ros"</div><div>Output: 3</div><div>Explanation: </div><div>horse -> rorse (replace 'h' with 'r')</div><div>rorse -> rose (remove 'r')</div><div>rose -> ros (remove 'e')</div><div></div><div>Example 2:</div><div></div><div>Input: word1 = "intention", word2 = "execution"</div><div>Output: 5</div><div>Explanation: </div><div>intention -> inention (remove 't')</div><div>inention -> enention (replace 'i' with 'e')</div><div>enention -> exention (replace 'n' with 'x')</div><div>exention -> exection (replace 'n' with 'c')</div><div>exection -> execution (insert 'u')</div><div></div> 	 <div>This problem is solved by dynamic programming. Consider two words, <code>w1</code> with length <code>l1</code> and <code>w2</code> with length <code>l2</code>. We use a matrix of size <code>(l1 + 1) * (l2 + 1)</code>, with each cell <code>dp[i][j]</code> representing the minimum number of operations to transform the first <code>i</code> letters of <code>w1</code> to first <code>j</code> letters of <code>w2</code>. We offset the number of rows and columns by 1 to represent the empty string.</div><div></div><div>Notice that when iterating through each row of the matrix, we are only using the cells in the row above and one cell before. So it is possible to optimize the space usage to only an 1-D array of size <code>min(l1, l2)</code>, since the count of operations from is symmetric for <code>w1</code> and <code>w2</code>.</div>
